<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PTA列出连通集</title>
      <link href="/2020/08/14/PTA%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/"/>
      <url>/2020/08/14/PTA%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>涉及BFS和DFS的一道基础遍历题，方便加深对BFS和DFS的理解</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第1行给出2个整数N( 0 &lt; N ≤ 10 )和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>按照”{ v<sub>1</sub>, v<sub>2</sub>, …, v<sub>k</sub> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><p>因为只会加入0到10个顶点，而且顶点从0到N-1编号，所以直接使用邻接矩阵，最大顶点数设10即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MAXN 10        &#x2F;* 最大顶点数 *&#x2F;</span><br><span class="line"></span><br><span class="line">int visited[MAXN];</span><br><span class="line"></span><br><span class="line">int G[MAXN][MAXN], Nv, Ne;</span><br><span class="line"></span><br><span class="line">void BuildGraph() &#123;</span><br><span class="line">    int i, j, v1, v2;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv);</span><br><span class="line">    for(i &#x3D; 0; i &lt; Nv; i++)</span><br><span class="line">        for(j &#x3D; 0; j &lt; Nv; j++)</span><br><span class="line">            G[i][j] &#x3D; 0;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Ne);</span><br><span class="line">    for(i &#x3D; 0; i &lt; Ne; i++) &#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;v1, &amp;v2);</span><br><span class="line">        G[v1][v2] &#x3D; 1;</span><br><span class="line">        G[v2][v1] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(int v) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    visited[v] &#x3D; 1;</span><br><span class="line">    printf(&quot;%d &quot;, v);</span><br><span class="line">    for(i &#x3D; 0; i &lt; Nv; i++) &#123;</span><br><span class="line">        if(!visited[i] &amp;&amp; G[v][i] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            DFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BFS(int s) &#123;</span><br><span class="line">    int queue[11];</span><br><span class="line">    int f &#x3D; 0, r &#x3D; 0;</span><br><span class="line">    int v, i;</span><br><span class="line">    queue[r++] &#x3D; s;</span><br><span class="line">    visited[s] &#x3D; 1;</span><br><span class="line">    printf(&quot;%d &quot;, s);</span><br><span class="line">    while(f !&#x3D; r) &#123;</span><br><span class="line">        v &#x3D; queue[f++];</span><br><span class="line">        for(i &#x3D; 0; i &lt; Nv; i++) &#123;</span><br><span class="line">            if(!visited[i] &amp;&amp; G[v][i] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                printf(&quot;%d &quot;, i);</span><br><span class="line">                visited[i] &#x3D; 1;</span><br><span class="line">                queue[r++] &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ClearNums() &#123;</span><br><span class="line">    memset(visited, 0, sizeof(visited));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i;</span><br><span class="line">    BuildGraph();</span><br><span class="line">    for(i &#x3D; 0; i &lt; Nv; i++) &#123;</span><br><span class="line">        if(!visited[i]) &#123;</span><br><span class="line">            printf(&quot;&#123; &quot;);</span><br><span class="line">            DFS(i);</span><br><span class="line">            printf(&quot;&#125;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ClearNums();</span><br><span class="line">    for(i &#x3D; 0; i &lt; Nv; i++) &#123;</span><br><span class="line">        if(!visited[i]) &#123;</span><br><span class="line">            printf(&quot;&#123; &quot;);</span><br><span class="line">            BFS(i);</span><br><span class="line">            printf(&quot;&#125;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA平衡二叉树的根</title>
      <link href="/2020/08/13/PTA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A0%B9/"/>
      <url>/2020/08/13/PTA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<p>涉及到左单旋、右单旋、左右双旋、右左双旋的操作，值得记录</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将给定的一系列数字插入初始为空的AVL树，请你输出最后生成的AVL树的根结点的值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行给出一个正整数N（≤20），随后一行给出N个不同的整数，其间以空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>在一行中输出顺序插入上述整数到一棵初始为空的AVL树后，该树的根结点的值。</p><h2 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br></pre></td></tr></table></figure><h2 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure><h2 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2"></a>输入样例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure><h2 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2"></a>输出样例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">88</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef int ElementType;</span><br><span class="line"></span><br><span class="line">typedef struct AVLNode *Position;</span><br><span class="line">typedef Position AVLTree; &#x2F;* AVL树类型 *&#x2F;</span><br><span class="line">struct AVLNode&#123;</span><br><span class="line">    ElementType Data; &#x2F;* 结点数据 *&#x2F;</span><br><span class="line">    AVLTree Left;     &#x2F;* 指向左子树 *&#x2F;</span><br><span class="line">    AVLTree Right;    &#x2F;* 指向右子树 *&#x2F;</span><br><span class="line">    int Height;       &#x2F;* 树高 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Max ( int a, int b )</span><br><span class="line">&#123;</span><br><span class="line">    return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetHeight( AVLTree A ) &#123;</span><br><span class="line">    if(A &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return A-&gt;Height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVLTree SingleLeftRotation ( AVLTree A )</span><br><span class="line">&#123; &#x2F;* 注意：A必须有一个左子结点B *&#x2F;</span><br><span class="line">  &#x2F;* 将A与B做左单旋，更新A与B的高度，返回新的根结点B *&#x2F;     </span><br><span class="line"> </span><br><span class="line">    AVLTree B &#x3D; A-&gt;Left;</span><br><span class="line">    A-&gt;Left &#x3D; B-&gt;Right;</span><br><span class="line">    B-&gt;Right &#x3D; A;</span><br><span class="line">    A-&gt;Height &#x3D; Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1;</span><br><span class="line">    B-&gt;Height &#x3D; Max( GetHeight(B-&gt;Left), A-&gt;Height ) + 1;</span><br><span class="line">  </span><br><span class="line">    return B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVLTree SingleRightRotation ( AVLTree A )</span><br><span class="line">&#123; &#x2F;* 注意：A必须有一个右子结点B *&#x2F;</span><br><span class="line">  &#x2F;* 将A与B做右单旋，更新A与B的高度，返回新的根结点B *&#x2F;</span><br><span class="line"></span><br><span class="line">    AVLTree B &#x3D; A-&gt;Right;</span><br><span class="line">    A-&gt;Right &#x3D; B-&gt;Left;</span><br><span class="line">    B-&gt;Left &#x3D; A;</span><br><span class="line">    A-&gt;Height &#x3D; Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1;</span><br><span class="line">    B-&gt;Height &#x3D; Max( GetHeight(B-&gt;Right), A-&gt;Height ) + 1;</span><br><span class="line"></span><br><span class="line">    return B;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">AVLTree DoubleLeftRightRotation ( AVLTree A )</span><br><span class="line">&#123; &#x2F;* 注意：A必须有一个左子结点B，且B必须有一个右子结点C *&#x2F;</span><br><span class="line">  &#x2F;* 将A、B与C做两次单旋，返回新的根结点C *&#x2F;</span><br><span class="line">     </span><br><span class="line">    &#x2F;* 将B与C做右单旋，C被返回 *&#x2F;</span><br><span class="line">    A-&gt;Left &#x3D; SingleRightRotation(A-&gt;Left);</span><br><span class="line">    &#x2F;* 将A与C做左单旋，C被返回 *&#x2F;</span><br><span class="line">    return SingleLeftRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVLTree DoubleRightLeftRotation ( AVLTree A )</span><br><span class="line">&#123; &#x2F;* 注意：A必须有一个左子结点B，且B必须有一个右子结点C *&#x2F;</span><br><span class="line">  &#x2F;* 将A、B与C做两次单旋，返回新的根结点C *&#x2F;</span><br><span class="line">     </span><br><span class="line">    &#x2F;* 将B与C做右单旋，C被返回 *&#x2F;</span><br><span class="line">    A-&gt;Right &#x3D; SingleLeftRotation(A-&gt;Right);</span><br><span class="line">    &#x2F;* 将A与C做左单旋，C被返回 *&#x2F;</span><br><span class="line">    return SingleRightRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVLTree Insert( AVLTree T, ElementType X )</span><br><span class="line">&#123; &#x2F;* 将X插入AVL树T中，并且返回调整后的AVL树 *&#x2F;</span><br><span class="line">    if ( !T ) &#123; &#x2F;* 若插入空树，则新建包含一个结点的树 *&#x2F;</span><br><span class="line">        T &#x3D; (AVLTree)malloc(sizeof(struct AVLNode));</span><br><span class="line">        T-&gt;Data &#x3D; X;</span><br><span class="line">        T-&gt;Height &#x3D; 0;</span><br><span class="line">        T-&gt;Left &#x3D; T-&gt;Right &#x3D; NULL;</span><br><span class="line">    &#125; &#x2F;* if (插入空树) 结束 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    else if ( X &lt; T-&gt;Data ) &#123;</span><br><span class="line">        &#x2F;* 插入T的左子树 *&#x2F;</span><br><span class="line">        T-&gt;Left &#x3D; Insert( T-&gt;Left, X);</span><br><span class="line">        &#x2F;* 如果需要左旋 *&#x2F;</span><br><span class="line">        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) &gt; 1 )</span><br><span class="line">            if ( X &lt; T-&gt;Left-&gt;Data ) </span><br><span class="line">               T &#x3D; SingleLeftRotation(T);      &#x2F;* 左单旋 *&#x2F;</span><br><span class="line">            else </span><br><span class="line">               T &#x3D; DoubleLeftRightRotation(T); &#x2F;* 左-右双旋 *&#x2F;</span><br><span class="line">    &#125; &#x2F;* else if (插入左子树) 结束 *&#x2F;</span><br><span class="line">     </span><br><span class="line">    else if ( X &gt; T-&gt;Data ) &#123;</span><br><span class="line">        &#x2F;* 插入T的右子树 *&#x2F;</span><br><span class="line">        T-&gt;Right &#x3D; Insert( T-&gt;Right, X );</span><br><span class="line">        &#x2F;* 如果需要右旋 *&#x2F;</span><br><span class="line">        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) &lt; -1 )</span><br><span class="line">            if ( X &gt; T-&gt;Right-&gt;Data ) </span><br><span class="line">               T &#x3D; SingleRightRotation(T);     &#x2F;* 右单旋 *&#x2F;</span><br><span class="line">            else </span><br><span class="line">               T &#x3D; DoubleRightLeftRotation(T); &#x2F;* 右-左双旋 *&#x2F;</span><br><span class="line">    &#125; &#x2F;* else if (插入右子树) 结束 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* else X &#x3D;&#x3D; T-&gt;Data，无须插入 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 别忘了更新树高 *&#x2F;</span><br><span class="line">    T-&gt;Height &#x3D; Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + 1;</span><br><span class="line">     </span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    AVLTree A &#x3D; NULL;</span><br><span class="line">    int height, X;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;height);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; height; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;X);</span><br><span class="line">        A &#x3D; Insert(A, X);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, A-&gt;Data);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA是否同一二叉搜索树</title>
      <link href="/2020/08/13/PTA%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2020/08/13/PTA%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>树的基本练习，算是吧。。。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。</p><p>简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct TreeNode *Tree;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int v;</span><br><span class="line">    Tree Left, Right;</span><br><span class="line">    int flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree NewNode(int V)</span><br><span class="line">&#123;</span><br><span class="line">    Tree T &#x3D; (Tree)malloc(sizeof(struct TreeNode));</span><br><span class="line">    T-&gt;v &#x3D; V;</span><br><span class="line">    T-&gt;Left &#x3D; T-&gt;Right &#x3D; NULL;</span><br><span class="line">    T-&gt;flag &#x3D; 0;</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree Insert(Tree T, int V) &#123;</span><br><span class="line">    if(!T)</span><br><span class="line">        T &#x3D; NewNode(V);</span><br><span class="line">    else &#123;</span><br><span class="line">        if(V &gt; T-&gt;v)</span><br><span class="line">            T-&gt;Right &#x3D; Insert(T-&gt;Right, V);</span><br><span class="line">        else</span><br><span class="line">            T-&gt;Left &#x3D; Insert(T-&gt;Left, V);</span><br><span class="line">    &#125;</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree MakeTree(int N)</span><br><span class="line">&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    int i, V;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;V);</span><br><span class="line">    T &#x3D; NewNode(V);</span><br><span class="line">    for(i &#x3D; 1; i &lt; N; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;V);</span><br><span class="line">        T &#x3D; Insert(T, V);</span><br><span class="line">    &#125;</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int check(Tree T, int V) &#123;</span><br><span class="line">    if(T-&gt;flag) &#123;</span><br><span class="line">        if(V &lt; T-&gt;v)</span><br><span class="line">            return check(T-&gt;Left, V);</span><br><span class="line">        else if(V &gt; T-&gt;v)</span><br><span class="line">            return check(T-&gt;Right, V);</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if(V &#x3D;&#x3D; T-&gt;v) &#123;</span><br><span class="line">            T-&gt;flag &#x3D; 1;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Judge(Tree T, int N) &#123;</span><br><span class="line">    int i, V, flag &#x3D; 0;     &#x2F;*flag &#x3D; 0代表目前还一致，1代表已经不一致*&#x2F;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;V);</span><br><span class="line">    if(V !&#x3D; T-&gt;v)</span><br><span class="line">        flag &#x3D; 1;</span><br><span class="line">    else</span><br><span class="line">        T-&gt;flag &#x3D; 1;</span><br><span class="line">    for(i &#x3D; 1; i &lt; N; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;V);</span><br><span class="line">        if((!flag) &amp;&amp; (!check(T, V)))</span><br><span class="line">            flag &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag)</span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">        return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ResetT(Tree T) &#123;</span><br><span class="line">    if(T-&gt;Left)</span><br><span class="line">        ResetT(T-&gt;Left);</span><br><span class="line">    if(T-&gt;Right)</span><br><span class="line">        ResetT(T-&gt;Right);</span><br><span class="line">    T-&gt;flag &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FreeTree(Tree T) &#123;</span><br><span class="line">    if(T-&gt;Left)</span><br><span class="line">        FreeTree(T-&gt;Left);</span><br><span class="line">    if(T-&gt;Right)</span><br><span class="line">        FreeTree(T-&gt;Right);</span><br><span class="line">    free(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, L, i;</span><br><span class="line">    Tree T;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    while(N) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;L);</span><br><span class="line">        T &#x3D; MakeTree(N);</span><br><span class="line">        for(i &#x3D; 0; i &lt; L; i++) &#123;</span><br><span class="line">            if(Judge(T, N)) &#123;</span><br><span class="line">                printf(&quot;Yes\n&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                printf(&quot;No\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            ResetT(T);   </span><br><span class="line">        &#125;</span><br><span class="line">        FreeTree(T);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树搜索树的操作集</title>
      <link href="/2020/08/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86/"/>
      <url>/2020/08/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>实现二叉搜索树的5种常用操作，C实现</p><a id="more"></a><h2 id="函数接口定义"><a href="#函数接口定义" class="headerlink" title="函数接口定义"></a>函数接口定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BinTree Insert( BinTree BST, ElementType X );</span><br><span class="line">BinTree Delete( BinTree BST, ElementType X );</span><br><span class="line">Position Find( BinTree BST, ElementType X );</span><br><span class="line">Position FindMin( BinTree BST );</span><br><span class="line">Position FindMax( BinTree BST );</span><br></pre></td></tr></table></figure><p>其中 <strong>BinTree</strong> 结构定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct TNode *Position;</span><br><span class="line">typedef Position BinTree;</span><br><span class="line">struct TNode&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>函数 <strong>Insert</strong> 将 <strong>X</strong> 插入二叉搜索树 <strong>BST</strong> 并返回结果树的根结点指针；</li><li>函数 <strong>Delete</strong> 将 <strong>X</strong> 从二叉搜索树 <strong>BST</strong> 中删除，并返回结果树的根结点指针；如果 <strong>X</strong> 不在树中，则打印一行 <strong>Not Found</strong> 并返回原树的根结点指针；</li><li>函数 <strong>Find</strong> 在二叉搜索树 <strong>BST</strong> 中找到 <strong>X</strong> ，返回该结点的指针；如果找不到则返回空指针；</li><li>函数 <strong>FindMin</strong> 返回二叉搜索树 <strong>BST</strong> 中最小元结点的指针；</li><li>函数 <strong>FindMax</strong> 返回二叉搜索树 <strong>BST</strong> 中最大元结点的指针。</li></ul><h2 id="裁判测试程序样例"><a href="#裁判测试程序样例" class="headerlink" title="裁判测试程序样例"></a>裁判测试程序样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int ElementType;</span><br><span class="line">typedef struct TNode *Position;</span><br><span class="line">typedef Position BinTree;</span><br><span class="line">struct TNode&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void PreorderTraversal( BinTree BT ); &#x2F;* 先序遍历，由裁判实现，细节不表 *&#x2F;</span><br><span class="line">void InorderTraversal( BinTree BT );  &#x2F;* 中序遍历，由裁判实现，细节不表 *&#x2F;</span><br><span class="line"></span><br><span class="line">BinTree Insert( BinTree BST, ElementType X );</span><br><span class="line">BinTree Delete( BinTree BST, ElementType X );</span><br><span class="line">Position Find( BinTree BST, ElementType X );</span><br><span class="line">Position FindMin( BinTree BST );</span><br><span class="line">Position FindMax( BinTree BST );</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    int N, i;</span><br><span class="line"></span><br><span class="line">    BST &#x3D; NULL;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    for ( i&#x3D;0; i&lt;N; i++ ) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;X);</span><br><span class="line">        BST &#x3D; Insert(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Preorder:&quot;); PreorderTraversal(BST); printf(&quot;\n&quot;);</span><br><span class="line">    MinP &#x3D; FindMin(BST);</span><br><span class="line">    MaxP &#x3D; FindMax(BST);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    for( i&#x3D;0; i&lt;N; i++ ) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;X);</span><br><span class="line">        Tmp &#x3D; Find(BST, X);</span><br><span class="line">        if (Tmp &#x3D;&#x3D; NULL) printf(&quot;%d is not found\n&quot;, X);</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;%d is found\n&quot;, Tmp-&gt;Data);</span><br><span class="line">            if (Tmp&#x3D;&#x3D;MinP) printf(&quot;%d is the smallest key\n&quot;, Tmp-&gt;Data);</span><br><span class="line">            if (Tmp&#x3D;&#x3D;MaxP) printf(&quot;%d is the largest key\n&quot;, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    for( i&#x3D;0; i&lt;N; i++ ) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;X);</span><br><span class="line">        BST &#x3D; Delete(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Inorder:&quot;); InorderTraversal(BST); printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 你的代码将被嵌在这里 *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">5 8 6 2 4 1 0 10 9 7</span><br><span class="line">5</span><br><span class="line">6 3 10 0 5</span><br><span class="line">5</span><br><span class="line">5 7 0 10 3</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Preorder: 5 2 1 0 4 8 6 7 10 9</span><br><span class="line">6 is found</span><br><span class="line">3 is not found</span><br><span class="line">10 is found</span><br><span class="line">10 is the largest key</span><br><span class="line">0 is found</span><br><span class="line">0 is the smallest key</span><br><span class="line">5 is found</span><br><span class="line">Not Found</span><br><span class="line">Inorder: 1 2 4 6 8 9</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Position Find( BinTree BST, ElementType X ) &#123;</span><br><span class="line">    while(BST) &#123;</span><br><span class="line">        if (X &gt; BST-&gt;Data) &#123;</span><br><span class="line">            BST &#x3D; BST-&gt;Right;</span><br><span class="line">        &#125; else if (X &lt; BST-&gt;Data) &#123;</span><br><span class="line">            BST &#x3D; BST-&gt;Left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return BST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">Position FindMin( BinTree BST ) &#123;</span><br><span class="line">    if(BST)</span><br><span class="line">    &#123;</span><br><span class="line">        while (BST-&gt;Left)</span><br><span class="line">        &#123;</span><br><span class="line">            BST &#x3D; BST-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br><span class="line">Position FindMax( BinTree BST ) &#123;</span><br><span class="line">    if(BST)</span><br><span class="line">    &#123;</span><br><span class="line">        while (BST-&gt;Right)</span><br><span class="line">        &#123;</span><br><span class="line">            BST &#x3D; BST-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br><span class="line">BinTree Insert( BinTree BST, ElementType X ) &#123;</span><br><span class="line">    if(!BST) &#123;</span><br><span class="line">        BST &#x3D; (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">        BST-&gt;Data &#x3D; X;</span><br><span class="line">        BST-&gt;Left &#x3D; BST-&gt;Right &#x3D; NULL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (X &lt; BST-&gt;Data) &#123;</span><br><span class="line">            BST-&gt;Left &#x3D; Insert(BST-&gt;Left, X);</span><br><span class="line">        &#125; else if(X &gt; BST-&gt;Data) &#123;</span><br><span class="line">            BST-&gt;Right &#x3D; Insert(BST-&gt;Right, X);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br><span class="line">BinTree Delete( BinTree BST, ElementType X ) &#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    if (!BST) &#123;</span><br><span class="line">        printf(&quot;Not Found\n&quot;);</span><br><span class="line">        return BST;</span><br><span class="line">    &#125;</span><br><span class="line">    if (X &lt; BST-&gt;Data) &#123;</span><br><span class="line">        BST-&gt;Left &#x3D; Delete(BST-&gt;Left, X);</span><br><span class="line">    &#125; else if (X &gt; BST-&gt;Data) &#123;</span><br><span class="line">        BST-&gt;Right &#x3D; Delete(BST-&gt;Right, X);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123;</span><br><span class="line">            Tmp &#x3D; FindMin(BST-&gt;Right);</span><br><span class="line">            BST-&gt;Data &#x3D; Tmp-&gt;Data;</span><br><span class="line">            BST-&gt;Right &#x3D; Delete(BST-&gt;Right, BST-&gt;Data);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Tmp &#x3D; BST;</span><br><span class="line">            if(!BST-&gt;Left) &#123;</span><br><span class="line">                BST &#x3D; BST-&gt;Right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                BST &#x3D; BST-&gt;Left;</span><br><span class="line">            &#125;</span><br><span class="line">            free(Tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树遍历</title>
      <link href="/2020/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
      <url>/2020/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>采用递归，不依赖队列的堆栈的四种遍历方法，适合拿来做PTA，C语言走起</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 先序遍历 *&#x2F;</span><br><span class="line">void PreOrderTraversal(BinTree BT) &#123;</span><br><span class="line">    if (BT) &#123;</span><br><span class="line">        printf(&quot; %c&quot;, BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);   &#x2F;&#x2F;递归用法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 中序遍历 *&#x2F;</span><br><span class="line">void InOrderTravelsal(BinTree BT) &#123;</span><br><span class="line">    if (BT) &#123;</span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        printf(&quot; %c&quot;, BT-&gt;Data);</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);   &#x2F;&#x2F;递归用法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 后序遍历 *&#x2F;</span><br><span class="line">void PostOrderTravelsal(BinTree BT) &#123;</span><br><span class="line">    if (BT) &#123;</span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);   &#x2F;&#x2F;递归用法</span><br><span class="line">        printf(&quot; %c&quot;, BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 层序遍历 *&#x2F;</span><br><span class="line">void LevelorderTraversal( BinTree BT ) &#123;</span><br><span class="line">    BinTree t[101];</span><br><span class="line">    int i, j;</span><br><span class="line">    i &#x3D; j &#x3D; 0;</span><br><span class="line">    t[0] &#x3D; BT;</span><br><span class="line">    while(BT) &#123;</span><br><span class="line">        if (BT-&gt;Left) &#123;</span><br><span class="line">            t[++i] &#x3D; BT-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        if (BT-&gt;Right) &#123;</span><br><span class="line">            t[++i] &#x3D; BT-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        BinTree temp &#x3D; t[j];</span><br><span class="line">        printf(&quot; %c&quot;, temp-&gt;Data);</span><br><span class="line">        if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        BT &#x3D; t[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA树的同构</title>
      <link href="/2020/08/13/PTA%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/"/>
      <url>/2020/08/13/PTA%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>树的操作，C语言实现，比较难理解的一道题- -|||</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p><p><img src="https://images.ptausercontent.com/28" alt="图1"></p><p><img src="https://images.ptausercontent.com/29" alt="图2"></p><p>现给定两棵树，请你判断它们是否是同构的。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p><h2 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">A 1 2</span><br><span class="line">B 3 4</span><br><span class="line">C 5 -</span><br><span class="line">D - -</span><br><span class="line">E 6 -</span><br><span class="line">G 7 -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line">8</span><br><span class="line">G - 4</span><br><span class="line">B 7 6</span><br><span class="line">F - -</span><br><span class="line">A 5 1</span><br><span class="line">H - -</span><br><span class="line">C 0 -</span><br><span class="line">D - -</span><br><span class="line">E 2 -</span><br></pre></td></tr></table></figure><h2 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2"></a>输入样例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">B 5 7</span><br><span class="line">F - -</span><br><span class="line">A 0 3</span><br><span class="line">C 6 -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G 4 -</span><br><span class="line">E 1 -</span><br><span class="line">8</span><br><span class="line">D 6 -</span><br><span class="line">B 5 -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C 0 2</span><br><span class="line">G - 3</span><br><span class="line">F - -</span><br><span class="line">A 1 4</span><br></pre></td></tr></table></figure><h2 id="输出样例1-1"><a href="#输出样例1-1" class="headerlink" title="输出样例1"></a>输出样例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MaxTree 10</span><br><span class="line">#define ElementType char</span><br><span class="line">#define Tree int</span><br><span class="line">#define Null -1</span><br><span class="line"> </span><br><span class="line">struct TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;T1[MaxTree], T2[MaxTree];</span><br><span class="line"> </span><br><span class="line">Tree BuildTree(struct TreeNode T[]);</span><br><span class="line">int Isomorphic(Tree R1, Tree R2);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Tree R1, R2;</span><br><span class="line">    R1 &#x3D; BuildTree(T1);</span><br><span class="line">    R2 &#x3D; BuildTree(T2);</span><br><span class="line">    if (Isomorphic(R1, R2))</span><br><span class="line">        printf(&quot;Yes\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;No\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Tree BuildTree(struct TreeNode T[])</span><br><span class="line">&#123;</span><br><span class="line">    int N;</span><br><span class="line">    char cl, cr;</span><br><span class="line">    int check[MaxTree];       &#x2F;&#x2F; 判断每一个节点有没有节点指向</span><br><span class="line">    int Root&#x3D;Null;</span><br><span class="line">    scanf(&quot;%d\n&quot;, &amp;N);</span><br><span class="line">    if (N)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">            check[i] &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%c %c %c\n&quot;, &amp;T[i].Element, &amp;cl, &amp;cr);</span><br><span class="line">            if (cl !&#x3D; &#39;-&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                T[i].Left &#x3D; cl - &#39;0&#39;;</span><br><span class="line">                check[T[i].Left] &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                T[i].Left &#x3D; Null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cr !&#x3D; &#39;-&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                T[i].Right &#x3D; cr - &#39;0&#39;;</span><br><span class="line">                check[T[i].Right] &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                T[i].Right &#x3D; Null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!check[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Root &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Root;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int Isomorphic(Tree R1, Tree R2)</span><br><span class="line">&#123;</span><br><span class="line">    if (R1 &#x3D;&#x3D; Null &amp;&amp; R2 &#x3D;&#x3D; Null)</span><br><span class="line">        return 1;</span><br><span class="line">    if ((R1 &#x3D;&#x3D; Null &amp;&amp; R2 !&#x3D; Null) || (R2 !&#x3D; Null &amp;&amp; R1 &#x3D;&#x3D; Null))</span><br><span class="line">        return 0;</span><br><span class="line">    if (T1[R1].Element !&#x3D; T2[R2].Element)</span><br><span class="line">        return 0;</span><br><span class="line">    if ((T1[R1].Left &#x3D;&#x3D; Null) &amp;&amp; (T2[R2].Left &#x3D;&#x3D; Null))</span><br><span class="line">        return Isomorphic(T1[R1].Right, T2[R2].Right);</span><br><span class="line">    &#x2F;&#x2F; 不需要交换左右子树</span><br><span class="line">    if (((T1[R1].Left !&#x3D; Null) &amp;&amp; (T2[R2].Left !&#x3D; Null)) &amp;&amp;</span><br><span class="line">        ((T1[T1[R1].Left].Element) &#x3D;&#x3D; T2[T2[R2].Left].Element))</span><br><span class="line">    &#123;</span><br><span class="line">        return (Isomorphic(T1[R1].Left, T2[R2].Left))&amp;&amp;</span><br><span class="line">            (Isomorphic(T1[R1].Right, T2[R2].Right));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 需要交换左右子数</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return (Isomorphic(T1[R1].Left, T2[R2].Right)) &amp;&amp;</span><br><span class="line">            (Isomorphic(T1[R1].Right, T2[R2].Left));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一元多项式的乘法与加法运算</title>
      <link href="/2020/08/13/PTA%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E5%92%8C%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/"/>
      <url>/2020/08/13/PTA%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E5%92%8C%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>C语言数组暴力解法，这比课堂上那个简单粗暴多了，方便记忆</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计函数分别求两个一元多项式的乘积与和。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出 <strong>0 0</strong>。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><p>i作为数组1下标，j作为数组2下标，对应多项式幂，数组存的内容就是系数，注意输出格式就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;t1,t2分别为0次输入数据，t3为乘法结果，t4为加法结果</span><br><span class="line">int t1[1005], t2[1005], t3[2005], t4[1005];</span><br><span class="line">#define max 1000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出函数，arr为结果数组，range为最大范围。</span><br><span class="line">void show(int *arr, int range)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int tag &#x3D; 0;</span><br><span class="line">    for(i &#x3D; range; i &gt;&#x3D; 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr[i] !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;输出的第一项前面没有空格，通过tag进行判断。</span><br><span class="line">            if(tag)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            tag &#x3D; 1;</span><br><span class="line">            printf(&quot;%d %d&quot;, arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;若最终tag为0表示没有输出过，整个结果为0，输出0 0</span><br><span class="line">    if(!tag)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;0 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n1, n2, i, j, a, b;</span><br><span class="line">    &#x2F;&#x2F;数组置0</span><br><span class="line">    memset(t1, 0, sizeof(t1));</span><br><span class="line">    memset(t2, 0, sizeof(t2));</span><br><span class="line">    memset(t3, 0, sizeof(t3));</span><br><span class="line">    memset(t4, 0, sizeof(t4));</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n1);</span><br><span class="line">    for(i &#x3D; 0; i &lt; n1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);</span><br><span class="line">        t1[b] &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n2);</span><br><span class="line">    for(i &#x3D; 0; i &lt; n2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);</span><br><span class="line">        t2[b] &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;计算乘法</span><br><span class="line">    for(i &#x3D; 0; i &lt;&#x3D; max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j &#x3D; 0; j &lt;&#x3D; max; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            t3[i + j] +&#x3D; t1[i] * t2[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;计算加法</span><br><span class="line">    for(i &#x3D; 0; i &lt;&#x3D; max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t4[i] &#x3D; t1[i] + t2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;输出</span><br><span class="line">    show(t3, max * 2);</span><br><span class="line">    show(t4, max);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA两个有序链表序列的合并</title>
      <link href="/2020/08/12/PTA%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6/"/>
      <url>/2020/08/12/PTA%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<p>考察链表基本操作，C语言解法</p><a id="more"></a><p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。</p><h2 id="函数接口定义"><a href="#函数接口定义" class="headerlink" title="函数接口定义"></a>函数接口定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List Merge( List L1, List L2 );</span><br></pre></td></tr></table></figure><p>其中 <strong>List</strong> 结构定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node &#123;</span><br><span class="line">    ElementType Data; &#x2F;* 存储结点数据 *&#x2F;</span><br><span class="line">    PtrToNode   Next; &#x2F;* 指向下一个结点的指针 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode List; &#x2F;* 定义单链表类型 *&#x2F;</span><br></pre></td></tr></table></figure><p><strong>L1</strong> 和 <strong>L2</strong> 是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数 <strong>Merge</strong> 要将 <strong>L1</strong> 和 <strong>L2</strong> 合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p><h2 id="裁判测试程序样例"><a href="#裁判测试程序样例" class="headerlink" title="裁判测试程序样例"></a>裁判测试程序样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int ElementType;</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node &#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode List;</span><br><span class="line"></span><br><span class="line">List Read(); &#x2F;* 细节在此不表 *&#x2F;</span><br><span class="line">void Print( List L ); &#x2F;* 细节在此不表；空链表将输出NULL *&#x2F;</span><br><span class="line"></span><br><span class="line">List Merge( List L1, List L2 );</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 &#x3D; Read();</span><br><span class="line">    L2 &#x3D; Read();</span><br><span class="line">    L &#x3D; Merge(L1, L2);</span><br><span class="line">    Print(L);</span><br><span class="line">    Print(L1);</span><br><span class="line">    Print(L2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 你的代码将被嵌在这里 *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><p>pa遍历L1, pb遍历L2, pc作为桥梁构建合链L</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List Merge( List L1, List L2 ) &#123;</span><br><span class="line">    List pa, pb, pc, L;</span><br><span class="line">    L &#x3D; (List)malloc(sizeof(struct Node));</span><br><span class="line">    pa &#x3D; L1-&gt;Next;</span><br><span class="line">    pb &#x3D; L2-&gt;Next;</span><br><span class="line">    pc &#x3D; L;</span><br><span class="line">    while(pa &amp;&amp; pb) &#123;</span><br><span class="line">        if (pa-&gt;Data &lt;&#x3D; pb-&gt;Data) &#123;</span><br><span class="line">            pc-&gt;Next &#x3D; pa;</span><br><span class="line">            pc &#x3D; pa;</span><br><span class="line">            pa &#x3D; pa-&gt;Next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pc-&gt;Next &#x3D; pb;</span><br><span class="line">            pc &#x3D; pb;</span><br><span class="line">            pb &#x3D; pb-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;Next &#x3D; pa ? pa : pb;</span><br><span class="line">    L1-&gt;Next &#x3D; NULL;</span><br><span class="line">    L2-&gt;Next &#x3D; NULL;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA二分查找法</title>
      <link href="/2020/08/12/PTA%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
      <url>/2020/08/12/PTA%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>挺早学但好像挺重要的，姑且记录一下，还是C语言解法</p><a id="more"></a><p>本题要求实现二分查找算法。</p><h2 id="函数接口定义"><a href="#函数接口定义" class="headerlink" title="函数接口定义"></a>函数接口定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Position BinarySearch( List L, ElementType X );</span><br></pre></td></tr></table></figure><p>其中 <strong>List</strong> 结构定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef int Position;</span><br><span class="line">typedef struct LNode *List;</span><br><span class="line">struct LNode &#123;</span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; &#x2F;* 保存线性表中最后一个元素的位置 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>L</strong> 是用户传入的一个线性表，其中 <strong>ElementType</strong> 元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数 <strong>BinarySearch</strong> 要查找 <strong>X</strong> 在 <strong>Data</strong> 中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记 <strong>NotFound</strong></p><h2 id="裁判测试程序样例"><a href="#裁判测试程序样例" class="headerlink" title="裁判测试程序样例"></a>裁判测试程序样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 10</span><br><span class="line">#define NotFound 0</span><br><span class="line">typedef int ElementType;</span><br><span class="line"></span><br><span class="line">typedef int Position;</span><br><span class="line">typedef struct LNode *List;</span><br><span class="line">struct LNode &#123;</span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; &#x2F;* 保存线性表中最后一个元素的位置 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">List ReadInput(); &#x2F;* 裁判实现，细节不表。元素从下标1开始存储 *&#x2F;</span><br><span class="line">Position BinarySearch( List L, ElementType X );</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    L &#x3D; ReadInput();</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;X);</span><br><span class="line">    P &#x3D; BinarySearch( L, X );</span><br><span class="line">    printf(&quot;%d\n&quot;, P);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 你的代码将被嵌在这里 *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><p>注意一下数据格式就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Position BinarySearch( List L, ElementType X ) &#123;</span><br><span class="line">    int low, high, mid;</span><br><span class="line">    low &#x3D; 0;</span><br><span class="line">    high &#x3D; L-&gt;Last;</span><br><span class="line">    while (low &lt;&#x3D; high) &#123;</span><br><span class="line">        mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">        if(X &#x3D;&#x3D; L-&gt;Data[mid]) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(X &lt; L-&gt;Data[mid]) &#123;</span><br><span class="line">            high &#x3D; mid - 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            low &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NotFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaximumSubsequenceSum解法</title>
      <link href="/2020/08/12/MaximumSubsequenceSum%E8%A7%A3%E6%B3%95/"/>
      <url>/2020/08/12/MaximumSubsequenceSum%E8%A7%A3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>最大子列和问题的变种，无非就是多加了找出最大子列和的第一个元素和最后一个元素</p><a id="more"></a><p>特点是在MaxSum更新的时候通过LastTag存入目前加上的数组元素的下标，从而找到最大子列和最后一个元素的下标，再倒推过来找到最大子列和的第一个元素的下标，存入FirstTag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int N, sum, FirstTag, LastTag, ThisSum, MaxSum, j, flag;</span><br><span class="line">    flag &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入数字个数：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    int* A &#x3D; (int*)malloc(sizeof(int)*N);</span><br><span class="line">    printf(&quot;请输入%d个数字：&quot;, N);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    ThisSum &#x3D; MaxSum &#x3D; 0;</span><br><span class="line">    for (j &#x3D; 0;j &lt; N;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum +&#x3D; A[j];</span><br><span class="line">        if (ThisSum &gt; MaxSum) &#123;</span><br><span class="line">            MaxSum &#x3D; ThisSum;</span><br><span class="line">            LastTag &#x3D; j;</span><br><span class="line">        &#125; else if (ThisSum &lt; 0)</span><br><span class="line">            ThisSum &#x3D; 0;</span><br><span class="line">        if(A[j] &gt;&#x3D; 0) &#123;</span><br><span class="line">            flag &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum &#x3D; 0;</span><br><span class="line">    for(int l &#x3D; LastTag; l &gt;&#x3D; 0; l--) &#123;</span><br><span class="line">        sum +&#x3D; A[l];</span><br><span class="line">        if(sum &#x3D;&#x3D; MaxSum) &#123;</span><br><span class="line">            FirstTag &#x3D; l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(MaxSum) &#123;</span><br><span class="line">        printf(&quot;最大子序列和为%d\n&quot;, MaxSum);</span><br><span class="line">    &#125; else if(flag) &#123;</span><br><span class="line">        printf(&quot;最大子序列和为0\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;最大子列和第一个元素为%d, 最后一个元素为%d\n&quot;, A[FirstTag], A[LastTag]);</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA最大子列和问题</title>
      <link href="/2020/08/12/PTA%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/12/PTA%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>采用C语言解法，后续可能会补充其他语种的写法</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定K个整数组成的序列{ N<sub>1</sub>, N<sub>2</sub>, …, N<sub>K</sub> }，“连续子列”被定义为{ N<sub>i</sub>, N<sub>i+1</sub>, …, N<sub>j</sub> }，其中 1 ≤ i ≤ j ≤ K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p><p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p><ul><li>数据1：与样例等价，测试基本正确性;</li><li>数据2：102个随机整数;</li><li>数据3：103个随机整数;</li><li>数据4：104个随机整数;</li><li>数据5：105个随机整数;</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第1行给出正整数K ( ≤100000 )；第2行给出K个整数，其间以空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">-2 11 -4 13 -5 -2</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><p>遍历整个数组时，ThisSum作为遍历数组的和，MaxSum不断靠ThisSum更新和大小，ThisSum &lt; 0时ThisSum会清零</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define MAXN 100000    &#x2F;&#x2F;本题最大数据是十万</span><br><span class="line"></span><br><span class="line">int MaxSubSequenceSum(const int A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    int ThisSum, MaxSum, j;</span><br><span class="line">    ThisSum &#x3D; MaxSum &#x3D; 0;</span><br><span class="line">    for (j &#x3D; 0;j &lt; N;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum +&#x3D; A[j];</span><br><span class="line">        if (ThisSum &gt; MaxSum)</span><br><span class="line">            MaxSum &#x3D; ThisSum;</span><br><span class="line">        else if (ThisSum &lt; 0)</span><br><span class="line">            ThisSum &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return MaxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int K, i;</span><br><span class="line">    </span><br><span class="line">    scanf(&quot;%d&quot;, &amp;K);</span><br><span class="line">    int* a &#x3D; (int*)malloc(sizeof(int)*K);</span><br><span class="line">    for ( i &#x3D; 0; i &lt; K; i++ )</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    printf(&quot;%d&quot;, MaxSubSequenceSum( a, K ));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语格助词全解</title>
      <link href="/2020/08/12/%E6%97%A5%E8%AF%AD%E6%A0%BC%E5%8A%A9%E8%AF%8D%E5%85%A8%E8%A7%A3/"/>
      <url>/2020/08/12/%E6%97%A5%E8%AF%AD%E6%A0%BC%E5%8A%A9%E8%AF%8D%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>整理一下日语的所有格助词用法，例如常用的が、を、に</p><p>仅供参考，怎么理解还得靠自己</p><a id="more"></a><h2 id="什么是格助词？"><a href="#什么是格助词？" class="headerlink" title="什么是格助词？"></a>什么是格助词？</h2><p>表达单词和动词直接的逻辑关系</p><p>日文所有格助词：が　を　に　へ　と　で　から　より　まで</p><h2 id="が"><a href="#が" class="headerlink" title="が"></a>が</h2><ol><li>表示动作或状态的主题（主词）</li></ol><ul><li><p>例：雨が　降ります</p><p>  りんごが　美味しいで</p></li></ul><ol start="2"><li>表示能力或者好恶的「对象」</li></ol><ul><li><p>例：お金が　欲しいです</p><p>  テレビが　買いたいです</p><p>  ドイツ語が　できます</p></li></ul><ol start="3"><li>加在名词后面成为新名词</li></ol><ul><li>例：我が国</li></ul><h2 id="を"><a href="#を" class="headerlink" title="を"></a>を</h2><ol><li>表示动作的对象</li></ol><ul><li><p>例：水を　飲みます</p><p>  映画を　見ます</p></li></ul><ol start="2"><li>表示移动空间</li></ol><ul><li><p>例：階段を　上がります</p><p>  公園を　散歩します　-&gt;  公園で（で表示动作的场所）</p></li></ul><ol start="3"><li>表示某段时间</li></ol><ul><li>例：楽しい　時間を　過ごしました</li></ul><ol start="4"><li>表示离开的场所</li></ol><ul><li>例：電車を　おります</li></ul><ol start="5"><li>表示一种感动或者特别提出某一点来讲</li></ol><ul><li>例：お忙しところを、どうもすみません</li></ul><h2 id="に"><a href="#に" class="headerlink" title="に"></a>に</h2><ol><li>表示存在的场所</li></ol><ul><li>例：つくえをの　上に　ノートが　あります</li></ul><ol start="2"><li>表示动作的时间或顺序</li></ol><ul><li><p>例：十時に　いきます</p><p>  一週間に　三回　デートを　します（某段时间内的动作频率）</p></li></ul><ol start="3"><li>表示拥有者</li></ol><ul><li>例：私には　子供が　二人　います</li></ul><ol start="4"><li>表示动作主</li></ol><ul><li><p>例：私には　できません</p><p>  部下に　これを　やらせます（使役）</p><p>  先生に　叱られました（被动）</p></li></ul><ol start="5"><li>表示归属附着点</li></ol><ul><li><p>例：電車に　乗ります</p><p>  壁に　ポスターを　貼ります</p></li></ul><ol start="6"><li>表示变化结果</li></ol><ul><li><p>例：水が　氷に　おりました</p><p>  ～に　なります＝～で　ございます</p><p>  紅茶に　おります（您点的红茶）</p></li></ul><ol start="7"><li>东西的接受者/受惠者（间接对象）</li></ol><ul><li><p>例：子供に　おやつを　あげます</p><p>  恋人に　記念品を　買います</p></li></ul><ol start="8"><li>表示动作的对象（没有触及对方的抽象动作）</li></ol><ul><li><p>例：お客さんに　会います</p><p>  先生に　聞きます</p><p>  母に　何を　もらいます</p></li></ul><ol start="9"><li>对象抽象</li></ol><ul><li><p>例：あなたの　意見に　賛成します</p><p>  天文学に　詳しいですね</p></li></ul><ol start="10"><li>表示目的</li></ol><ul><li>例：新宿へ　買い物に　行きます</li></ul><ol start="11"><li>原因</li></ol><ul><li>例：勉強に　疲れました（心理）  -&gt;  勉強で　疲れました（生理）</li></ul><ol start="12"><li>附加</li></ol><ul><li>例：黒のスーツに　黒のネクタイの　男が　いる</li></ul><ol start="13"><li>表示动作的重复</li></ol><ul><li>例：走りに　走って　やっと　間に合いました</li></ul><h2 id="へ"><a href="#へ" class="headerlink" title="へ"></a>へ</h2><ol><li>动作方向</li></ol><ul><li><p>例：自宅へ　向かいます</p><p>  部屋へ　戻ります</p><p>  彼女への　プレゼントを　買います</p></li></ul><h2 id="と"><a href="#と" class="headerlink" title="と"></a>と</h2><ol><li>表示并列</li></ol><ul><li>例：教室に　山田さんと　林さんが　います</li></ul><ol start="2"><li>表示一起做某动作的对方</li></ol><ul><li>例：花子と　結婚しました</li></ul><ol start="3"><li>表示对称关系</li></ol><ul><li>例：以前と　違います</li></ul><ol start="4"><li>表示对话或思考的内容</li></ol><ul><li>例：安井さんも　行くと　言いましたよ</li></ul><ol start="5"><li>表示变化的结果</li></ol><ul><li><p>例：雪が　雨と　ありました</p><p>  塵も　積もれば　山と　なります</p></li></ul><ol start="6"><li>表示加强一种状态</li></ol><ul><li><p>例：うわさは　人から　人へと　伝わるものです</p><p>  あの選手は　小柄ながら　三位と　健闘しました</p><p>  ずっと　きっと　たっと　二度と</p></li></ul><h2 id="で"><a href="#で" class="headerlink" title="で"></a>で</h2><ol><li>表示动作的场所</li></ol><ul><li><p>例：教室で　勉強します</p><p>  教室の中で　弁当を　食べました</p></li></ul><ol start="2"><li>表示工具、方法、手段</li></ol><ul><li><p>例：自転車で　行きます</p><p>  鉛筆で　書きます</p></li></ul><ol start="3"><li>表示原因</li></ol><ul><li><p>例：風邪で　会社を　休みました</p><p>  寒さで　震えます</p></li></ul><ol start="4"><li>表示材料</li></ol><ul><li><p>例：紙で　飛行機を　作ります</p><p>  試験の結果で　判断します</p></li></ul><ol start="5"><li>表范围、限度</li></ol><ul><li><p>例：15人で　締め切ります</p><p>  一週間で　習得します</p></li></ul><ol start="6"><li>表示状态</li></ol><ul><li><p>例：今年で　二十歳に　なります</p><p>  大声で　叫びます</p></li></ul><ol start="7"><li>表动作者</li></ol><ul><li>例：みんあで　協力して　大会を　成功させましぃう</li></ul><ol start="8"><li>表示最低限度或方法</li></ol><ul><li>例：あなたの　そばに　いるだけで、幸せです</li></ul><h2 id="から（从……去……）"><a href="#から（从……去……）" class="headerlink" title="から（从……去……）"></a>から（从……去……）</h2><ol><li>表示动作或时间的起点</li></ol><ul><li><p>例：学校は　明日から　始まります</p><p>  大学から　でました（从大学走出来） -&gt; 大学を　出ました（从大学毕业）</p></li></ul><ol start="2"><li>表动作者</li></ol><ul><li>例：そのことは　私から　先生に　伝えますね</li></ul><ol start="3"><li>表示经过点</li></ol><ul><li>例：窓から　入りました</li></ul><ol start="4"><li>表示原因/理由/判断依据</li></ol><ul><li>例：別の立場から　考えます</li></ul><ol start="5"><li>表示原料（看不出原料的原样）-&gt; で（看得出原料）</li></ol><ul><li>例：酒は米から作られます</li></ul><ol start="6"><li>表示被动式里边的动作者</li></ol><ul><li><p>例：あの先生は　みんなから　尊敬されています</p><p>  このことは　同級生から　教えられました</p></li></ul><h2 id="まで"><a href="#まで" class="headerlink" title="まで"></a>まで</h2><ol><li>表示动作或者事情结束的时间跟地点</li></ol><ul><li><p>例：福岡まで　飛行機で　いきました</p><p>  仕事が　終わるまで　待ちましょう</p></li></ul><ol start="2"><li>用「～から　～まで」的句型表示明确的范围</li></ol><ul><li><p>例：仕事は　九時から　五時までです</p></li><li><p>不明确范围用「～から　～に　かけて」</p><ul><li>例：東京から　名古屋に　かけて　大雨の　恐れが　あります</li></ul></li></ul><ol start="3"><li>表最低限度，「连……都……」</li></ol><ul><li><p>例：雪まで降ってきた</p><p>  あなたが　泣きと、私もで　悲しく　なります</p></li></ul><h2 id="より"><a href="#より" class="headerlink" title="より"></a>より</h2><ol><li>比较/选择的对象</li></ol><ul><li><p>例：アメリカは　日本より　大きいです</p><p>  花より　団子</p></li></ul><ol start="2"><li>表示地点或者时间的起点</li></ol><ul><li><p>例：四時より　会議を　始めます</p><p>  遠方より　昔の友達が　やってきました</p></li></ul><ol start="3"><li>表示一种限定（除了……别的方法）</li></ol><ul><li>例：待つより　仕方が　ありません</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语动词变形方法全解</title>
      <link href="/2020/08/12/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/"/>
      <url>/2020/08/12/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>在学习日语的过程中动词变形还是比较难的一道坎，在此做一个整理。</p><a id="more"></a><h3 id="1、动词ます形变化规则"><a href="#1、动词ます形变化规则" class="headerlink" title="1、动词ます形变化规则"></a>1、动词ます形变化规则</h3><p>五段动词：将结尾假名变成它同行的前一个假名后+ます</p><ul><li>例：行く～行きます　　買う～買います</li></ul><p>一段动词：去る＋ます</p><ul><li>例：食べる～食べます　　起きる～起きます</li></ul><p>カ变动词：来（く）る～来（き）ます</p><p>サ变动词：する～します</p><ul><li>例：勉強する～勉強します</li><li>特殊五段动词：帰る～帰ります　　知る～知ります<br>　　　　　　　入る～入ります　　要る～要ります<br>　　　　　　　切る～切ります　　走る～走ります 等<h3 id="2、动词ない形"><a href="#2、动词ない形" class="headerlink" title="2、动词ない形"></a>2、动词ない形</h3></li></ul><p>五段动词：将结尾假名变成它同行的あ段上的假名后+ない。</p><ul><li>例：行く→行かない　　買う→買わない</li></ul><p>一段动词：去る+ない</p><ul><li>例：食べる→食べない　　起きる→起きない</li></ul><p>カ变动词：来る→来（こ）ない</p><p>サ变动词：する→しない</p><ul><li><p>例：勉強する→勉強しない</p></li><li><p>特殊五段动词：帰る→帰らない　　知る→知らない</p></li><li><p>其它的以此类推，将る变成ら+ない</p></li></ul><h3 id="3、动词可能形"><a href="#3、动词可能形" class="headerlink" title="3、动词可能形"></a>3、动词可能形</h3><p>五段动词：将结尾假名变成它同行的下一个假名后+る。</p><ul><li>例：行く→行ける　　買う→買える</li></ul><p>一段动词：去る+られる。</p><ul><li>例：食べる→食べられる　　起きる→起きられる</li></ul><p>カ变动词：来る→来（こ）られる</p><p>サ变动词：する→できる</p><ul><li>例：勉強する→勉強できる</li></ul><h3 id="4、动词て形"><a href="#4、动词て形" class="headerlink" title="4、动词て形"></a>4、动词て形</h3><p>五段动词：</p><p>く→いて　　ぐ→いで</p><ul><li>例：書く→書いて　脱ぐ→脱いで</li></ul><p>う、つ、る为结尾的，去掉う、つ、る＋って</p><ul><li>例：買う→買って　　立つ→立って　　終わる→終わって</li></ul><p>む、ぬ、ぶ为结尾的去掉+む、ぬ、ぶ＋んで　</p><ul><li>例：飲む→飲んで　　死ぬ→死んで　　飛ぶ→飛んで</li></ul><p>以す为结尾的す→して</p><ul><li>例：話す→話して</li></ul><p>一段动词：去る+て</p><ul><li>例：食べる→食べて　　起きる→起きて</li></ul><p>カ变动词：来る→来（き）て</p><p>サ变动词：する→して</p><ul><li>例：勉強する→勉強して</li><li>例外：行く→行って　　帰る→帰って　　知る→知って</li></ul><h3 id="5、假定形"><a href="#5、假定形" class="headerlink" title="5、假定形"></a>5、假定形</h3><p>五段动词：将结尾假名变成它同行的下一个假名后+ば</p><ul><li>例：行く→行けば　　買う→買えば</li></ul><p>一段动词：去る+れば</p><ul><li>例：食べる→食べれば　　起きる→起きれば</li></ul><p>カ变动词： 来る→来（く）れば</p><p>サ变动词： する→すれば</p><ul><li>例：散歩する→散歩すれば</li></ul><p>形容词：去い+ければ</p><ul><li>例：安い→安ければ　　おいしい→おいしければ</li></ul><p>形容动词：去だ+なら</p><ul><li>例：暇だ→暇なら　　簡単だ→簡単なら</li><li>名词：名词直接+なら</li><li>例：日本人→日本人なら</li></ul><h3 id="6、动词意向形"><a href="#6、动词意向形" class="headerlink" title="6、动词意向形"></a>6、动词意向形</h3><p>五段动词：将结尾假名变成它同行的最后一个假名后+う</p><ul><li>例：行く→行こう　　買う→買おう</li></ul><p>一段动词：去る+よう</p><ul><li>例：食べる→食べよう　　起きる→起きよう</li></ul><p>カ变动词： 来る→来（こ）よう</p><p>サ变动词： する→しよう</p><ul><li>例：散歩する→散歩しよう</li></ul><h3 id="7、动词命令形"><a href="#7、动词命令形" class="headerlink" title="7、动词命令形"></a>7、动词命令形</h3><p>五段动词：将结尾假名变成它同行的下一个假名即可.</p><ul><li>例：行く→行け　　買う→買え</li></ul><p>一段动词：去る+ろ</p><ul><li>例：起きる→起きろ　　食べる→食べろ</li></ul><p>カ变动词： 来る→来（こ）い</p><p>サ变动词： する→しろ/せよ</p><ul><li>例：勉強する→勉強しろ/せよ</li><li>动词禁止形是所有词的字典形（原形、基本形）+な</li><li>例：行く→行くな　　起きる→起きるな　　来る→来（く）るな　　勉強する→勉強するな</li></ul><h3 id="8、动词被动形"><a href="#8、动词被动形" class="headerlink" title="8、动词被动形"></a>8、动词被动形</h3><p>五段动词：将结尾假名变成它所在行的あ段上假名后+れる</p><ul><li>例：踏む→踏まれる　　呼ぶ→呼ばれる</li></ul><p>一段动词：去る+られる</p><ul><li>例：褒める→褒められる　　食べる→食べられる</li></ul><p>カ变动词： 来る→来（こ）られる</p><p>サ变动词： する→される</p><ul><li>例：発明する→発明される</li></ul><h3 id="9、动词使役形"><a href="#9、动词使役形" class="headerlink" title="9、动词使役形"></a>9、动词使役形</h3><p>五段动词：将结尾假名变成它所在行的あ段上假名后+せる。</p><ul><li>例：行く→行かせる　　飲む→飲ませる</li></ul><p>一段动词：去る+させる</p><ul><li>例：食べる→食べさせる　　起きる→起きさせる</li></ul><p>カ变动词： 来る→来（こ）させる</p><p>サ变动词： する→させる</p><ul><li>例：勉強する→勉強させる</li></ul><p><a href="https://jp.hjenglish.com/riyuyufa/p176653/">沪江日语原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 日语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2020/08/09/hello-world/"/>
      <url>/2020/08/09/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:50px;font-family:UD Digi Kyokasho NP-B"><center> A New Start </center></h1><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/Typhoonix/CDN-for-blog@1.12/images/wallpaper1.png" alt="夕陽を背にPixiv ID:70336750Member:みふる"></p><p>和其他大佬不一样，我是第一次搭建个人博客</p><p>多亏大佬们的博文，基于Github Page和hexo搭建的博客上手起来不难，不过还有很多细节需要慢慢添加调整，估计建起一个美观与实用兼顾的博客需要耗费不少精力 - -|||</p><p>回到博客这边，为什么要写博客，有以下好处：</p><ol><li>觉得懂未必懂，写作是一个很好的反思过程</li><li>好记性不如烂笔头，容易遗忘的知识点通过浏览写过的博客能快速重新掌握</li><li>结交志同道合的朋友，大佬之间经常通过博客作为交流渠道，不过目前这不是重点</li></ol><p>博客的内容大部分会记录我学过的一些知识、错题和遇到的种种BUG，如果学到了大体系的知识也会考虑记录进博客做整理</p><p>博客配置，主题采用volantis，使用github进行版本控制，后边可能会考虑用上coding</p><p>这是一次全新的开始，祝：</p><p>一路开心！</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
