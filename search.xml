<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Tomcat的HTTP请求</title>
      <link href="/2020/10/13/Tomcat%E7%9A%84HTTP%E8%AF%B7%E6%B1%82/"/>
      <url>/2020/10/13/Tomcat%E7%9A%84HTTP%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>Tomcat的http请求方式如下</p><p><img src="https://img-blog.csdn.net/20180308173032224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDIzMTY0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><ol><li>用户点击网页内容，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得。 </li><li>Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应。 </li><li>Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host。 </li><li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有的Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）。 </li><li>path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL PATTERN为*.jsp的Servlet,对应于JspServlet类。 </li><li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet（）或doPost（）.执行业务逻辑、数据存储等程序。 </li><li>Context把执行完之后的HttpServletResponse对象返回给Host。 </li><li>Host把HttpServletResponse对象返回给Engine。 </li><li>Engine把HttpServletResponse对象返回Connector。 </li><li>Connector把HttpServletResponse对象返回给客户Browser。</li></ol><p>参考博文：<a href="https://blog.csdn.net/u014231646/article/details/79482195">Tomcat简介</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Web Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Web Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java单例模式详解</title>
      <link href="/2020/10/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/10/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>关于java单例模式的详解，面试貌似会经常碰到，而且里边也藏着很深的知识点，特此记录一下</p><a id="more"></a><p>首先是简单的实现方法</p><p>懒汉式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;  &#x2F;&#x2F;私有构造函数</span><br><span class="line">    private static Singleton instance &#x3D; null;  &#x2F;&#x2F;单例对象</span><br><span class="line">    &#x2F;&#x2F;静态工厂方法</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            instance &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance &#x3D; new Singleton();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 私有化构造方法</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这样写呢？我们来解释几个关键点：</p><p>1.要想让一个类只能构建一个对象，自然不能让它随便去做new操作，因此Signleton的构造方法是私有的。</p><p>2.instance是Singleton类的静态成员，也是我们的单例对象。它的初始值可以写成Null，也可以写成new Singleton()。至于其中的区别后来会做解释。</p><p>3.getInstance是获取单例对象的方法。</p><p>如果单例初始值是null，还未构建，则构建单例对象并返回。这个写法属于单例模式当中的<strong>懒汉模式</strong>。</p><p>如果单例对象一开始就被new Singleton()主动构建，则不再需要判空操作，这种写法属于<strong>饿汉模式</strong>。</p><p>这两个名字很形象：饿汉主动找食物吃，懒汉躺在地上等着人喂。</p><p><strong>但此写法的线程并不安全</strong></p><p>why？</p><p>假设Singleton类刚刚被初始化，instance对象还是空，这时候两个线程同时访问getInstance方法：</p><p><img src="https://pic2.zhimg.com/80/v2-481b3eb9e0e8b2388e6f9a60b09c8365_720w.jpg"></p><p>因为Instance是空，所以两个线程同时通过了条件判断，开始执行new操作：</p><p><img src="https://pic3.zhimg.com/80/v2-612ecb9f6761339b4689226fa1cf32e2_720w.jpg"></p><p>这样一来，显然instance被构建了两次。让我们对代码做一下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;  &#x2F;&#x2F;私有构造函数</span><br><span class="line">   private static Singleton instance &#x3D; null;  &#x2F;&#x2F;单例对象</span><br><span class="line">   &#x2F;&#x2F;静态工厂方法</span><br><span class="line">   public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;      &#x2F;&#x2F;双重检测机制</span><br><span class="line">         synchronized (Singleton.class)&#123;  &#x2F;&#x2F;同步锁</span><br><span class="line">           if (instance &#x3D;&#x3D; null) &#123;     &#x2F;&#x2F;双重检测机制</span><br><span class="line">             instance &#x3D; new Singleton();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这样写呢？我们来解释几个关键点：</p><p>1.为了防止new Singleton被执行多次，因此在new操作之前加上Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）。</p><p>2.进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。</p><p><img src="https://pic3.zhimg.com/80/v2-08b6606026cce318b0a9c3a5242ddba2_720w.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-0f9fc324f108c05c5c84d3273bfb49ec_720w.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-824f26d3d831cd4e70ae518e85718b4d_720w.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-5b0116783c1965f2e5921a97ccbd3414_720w.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-611429cbf0b532056113e0d2eb36d911_720w.jpg"></p><p>像这样两次判空的机制叫做<strong>双重检测机制</strong>。</p><p><strong>可是这并非是绝对线程安全的</strong></p><p>why?</p><p>这里涉及到了JVM编译器的<strong>指令重排</strong>。</p><p>指令重排是什么意思呢？比如java中简单的一句 instance = new Singleton，会被编译器编译成如下JVM指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memory &#x3D;allocate(); &#x2F;&#x2F;1：分配对象的内存空间</span><br><span class="line"></span><br><span class="line">ctorInstance(memory); &#x2F;&#x2F;2：初始化对象</span><br><span class="line"></span><br><span class="line">instance &#x3D;memory; &#x2F;&#x2F;3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure><p>但是这些指令顺序并非一成不变，有可能会经过JVM和CPU的优化，指令重排成下面的顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memory &#x3D;allocate(); &#x2F;&#x2F;1：分配对象的内存空间</span><br><span class="line"></span><br><span class="line">instance &#x3D;memory; &#x2F;&#x2F;3：设置instance指向刚分配的内存地址</span><br><span class="line"></span><br><span class="line">ctorInstance(memory); &#x2F;&#x2F;2：初始化对象</span><br></pre></td></tr></table></figure><p>当线程A执行完1,3,时，instance对象还未完成初始化，但已经不再指向null。此时如果线程B抢占到CPU资源，执行 if（instance == null）的结果会是false，从而返回一个没有初始化完成的instance对象。如下图所示：</p><p><img src="https://pic4.zhimg.com/80/v2-0d53745df463dc56e2990a165a50ef9b_720w.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-a9def40d42fd3a2e53f84e95112733a6_720w.jpg"></p><p>如何避免这一情况呢？我们需要在instance对象前面增加一个修饰符<strong>volatile</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;  &#x2F;&#x2F;私有构造函数</span><br><span class="line">    private volatile static Singleton instance &#x3D; null;  &#x2F;&#x2F;单例对象</span><br><span class="line">    &#x2F;&#x2F;静态工厂方法</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">          if (instance &#x3D;&#x3D; null) &#123;      &#x2F;&#x2F;双重检测机制</span><br><span class="line">         synchronized (Singleton.class)&#123;  &#x2F;&#x2F;同步锁</span><br><span class="line">           if (instance &#x3D;&#x3D; null) &#123;     &#x2F;&#x2F;双重检测机制</span><br><span class="line">             instance &#x3D; new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return instance;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile修饰符阻止了变量访问前后的指令重排，保证了指令执行顺序。</p><p>经过volatile的修饰，当线程A执行instance = new Singleton的时候，JVM执行顺序是什么样？始终保证是下面的顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memory &#x3D;allocate(); &#x2F;&#x2F;1：分配对象的内存空间</span><br><span class="line"></span><br><span class="line">ctorInstance(memory); &#x2F;&#x2F;2：初始化对象</span><br><span class="line"></span><br><span class="line">instance &#x3D;memory; &#x2F;&#x2F;3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure><p>如此在线程B看来，instance对象的引用要么指向null，要么指向一个初始化完毕的Instance，而不会出现某个中间态，保证了安全。</p><p><strong>还有其他实现单例模式的方法：</strong></p><p>用静态内部类实现单例模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static class LazyHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个需要注意的点：</p><p>1.从外部无法访问静态内部类LazyHolder，只有当调用Singleton.getInstance方法的时候，才能得到单例对象INSTANCE。</p><p>2.INSTANCE对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。因此这种实现方式是利用<strong>classloader的加载机制</strong>来实现懒加载，并保证构建单例的线程安全。</p><p>利用反射打破单例模式的约束，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获得构造器</span><br><span class="line">Constructor con &#x3D; Singleton.class.getDeclaredConstructor();</span><br><span class="line">&#x2F;&#x2F;设置为可访问</span><br><span class="line">con.setAccessible(true);</span><br><span class="line">&#x2F;&#x2F;构造两个不同的对象</span><br><span class="line">Singleton singleton1 &#x3D; (Singleton)con.newInstance();</span><br><span class="line">Singleton singleton2 &#x3D; (Singleton)con.newInstance();</span><br><span class="line">&#x2F;&#x2F;验证是否是不同对象</span><br><span class="line">System.out.println(singleton1.equals(singleton2));</span><br></pre></td></tr></table></figure><p>代码可以简单归纳为三个步骤：</p><p>第一步，获得单例类的构造器。</p><p>第二步，把构造器设置为可访问。</p><p>第三步，使用newInstance方法构造对象。</p><p>最后为了确认这两个对象是否真的是不同的对象，我们使用equals方法进行比较。毫无疑问，比较结果是false。</p><p>可以用枚举法实现单例模式，防止反射，也能保证线程安全：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用枚举法的情况下仍然执行刚刚的反射代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获得构造器</span><br><span class="line">Constructor con &#x3D; Singleton.class.getDeclaredConstructor();</span><br><span class="line">&#x2F;&#x2F;设置为可访问</span><br><span class="line">con.setAccessible(true);</span><br><span class="line">&#x2F;&#x2F;构造两个不同的对象</span><br><span class="line">Singleton singleton1 &#x3D; (Singleton)con.newInstance();</span><br><span class="line">Singleton singleton2 &#x3D; (Singleton)con.newInstance();</span><br><span class="line">&#x2F;&#x2F;验证是否是不同对象</span><br><span class="line">System.out.println(singleton1.equals(singleton2));</span><br></pre></td></tr></table></figure><p>执行获得构造器这一步的时候，抛出了如下异常：</p><p>Exception in thread “main” java.lang.NoSuchMethodException: com.xiaohui.singleton.test.SingletonEnum.<init>()</p><p>at java.lang.Class.getConstructor0(Class.java:2892)</p><p>at java.lang.Class.getDeclaredConstructor(Class.java:2058)</p><p>at com.xiaohui.singleton.test.SingletonTest.main(SingletonTest.java:22)</p><p>at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</p><p>at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</p><p>at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</p><p>at java.lang.reflect.Method.invoke(Method.java:606)</p><p>at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)</p><p>枚举法缺点：并非使用懒加载，其单例模式是在枚举类被加载的时候进行初始化的。</p><p><strong>总结：</strong></p><p><img src="https://pic1.zhimg.com/80/v2-cd8485a2a815ee615d5857a98702e8f0_720w.jpg"></p><p>几点补充：</p><ol><li><p>volatile关键字不但可以防止指令重排，也可以保证线程访问的变量值是主内存中的最新值。有关volatile的详细原理，我在以后的漫画中会专门讲解。</p></li><li><p>使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现readResolve方法。</p></li></ol><p>参考博文：</p><p><a href="https://zhuanlan.zhihu.com/p/33102022">漫画：什么是单例模式</a></p><p><a href="https://blog.csdn.net/fd2025/article/details/79711198">java 单例模式的几种实现方式</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA排序算法</title>
      <link href="/2020/08/22/PTA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/08/22/PTA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>整理一下各种排序算法的C语言写法以及运行结果，对排序有个清晰认知</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定N个（长整型范围内的）整数，要求输出从小到大排序后的结果。</p><p>本题旨在测试各种不同的排序算法在各种数据情况下的表现。各组测试数据特点如下：</p><p>数据1：只有1个元素；</p><p>数据2：11个不相同的整数，测试基本正确性；</p><p>数据3：10<sup>3</sup>个随机整数；</p><p>数据4：10<sup>4</sup>个随机整数；</p><p>数据5：10<sup>5</sup>个随机整数；</p><p>数据6：10<sup>5</sup>个顺序整数；</p><p>数据7：10<sup>5</sup>个逆序整数；</p><p>数据8：10<sup>5</sup>个基本有序的整数；</p><p>数据9：10<sup>5</sup>个随机正整数，每个数字不超过1000。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行给出正整数N（ ≤10<sup>5</sup> ），随后一行给出N个（长整型范围内的）整数，其间以空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">4 981 10 -17 0 -20 29 50 8 43 -5</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-20 -17 -5 0 4 8 10 29 43 50 981</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ol><li><p>选择排序（大数据直接运行超时）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*PTA运行成功*&#x2F;</span><br><span class="line">void InsertionSort(int a[], int n)</span><br><span class="line">&#123; &#x2F;* 插入排序 *&#x2F;</span><br><span class="line">    int P, i;</span><br><span class="line">    int Tmp;</span><br><span class="line"></span><br><span class="line">    for (P &#x3D; 1; P &lt; n; P++)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp &#x3D; a[P]; &#x2F;* 取出未排序序列中的第一个元素*&#x2F;</span><br><span class="line">        for (i &#x3D; P; i &gt; 0 &amp;&amp; a[i - 1] &gt; Tmp; i--)</span><br><span class="line">            a[i] &#x3D; a[i - 1]; &#x2F;*依次与已排序序列中元素比较并右移*&#x2F;</span><br><span class="line">        a[i] &#x3D; Tmp;          &#x2F;* 放进合适的位置 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, a[i], i &lt; n - 1 ? &#39; &#39; : &#39;\n&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, i;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    int* a &#x3D; (int*)malloc(sizeof(int)*n);</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    InsertionSort(a, n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Typhoonix/CDN-for-blog@1.15/images/%E6%8E%92%E5%BA%8Fblog/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4.png" alt="运行结果图"></p></li><li><p>冒泡排序（部分大数据会超时）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*PTA数据5和数据9运行会超时*&#x2F;</span><br><span class="line">void Bubble_Sort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, t;</span><br><span class="line">    int flag;</span><br><span class="line">    for (i &#x3D; 0; i &lt; n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag &#x3D; 0;   &#x2F;*加一个标识符方便快速排完序*&#x2F;</span><br><span class="line">        for (j &#x3D; 0; j &lt; n - 1 - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[j] &gt; a[j + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                t &#x3D; a[j];</span><br><span class="line">                a[j] &#x3D; a[j + 1];</span><br><span class="line">                a[j + 1] &#x3D; t;</span><br><span class="line">                flag &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, a[i], i &lt; n - 1 ? &#39; &#39; : &#39;\n&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, i;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    int* a &#x3D; (int*)malloc(sizeof(int)*n);</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Bubble_Sort(a, n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Typhoonix/CDN-for-blog@1.15/images/%E6%8E%92%E5%BA%8Fblog/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4.png" alt="运行结果图"></p></li><li><p>插入排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*PTA运行成功*&#x2F;</span><br><span class="line">void InsertionSort(int a[], int n)</span><br><span class="line">&#123; &#x2F;* 插入排序 *&#x2F;</span><br><span class="line">    int P, i;</span><br><span class="line">    int Tmp;</span><br><span class="line"></span><br><span class="line">    for (P &#x3D; 1; P &lt; n; P++)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp &#x3D; a[P]; &#x2F;* 取出未排序序列中的第一个元素*&#x2F;</span><br><span class="line">        for (i &#x3D; P; i &gt; 0 &amp;&amp; a[i - 1] &gt; Tmp; i--)</span><br><span class="line">            a[i] &#x3D; a[i - 1]; &#x2F;*依次与已排序序列中元素比较并右移*&#x2F;</span><br><span class="line">        a[i] &#x3D; Tmp;          &#x2F;* 放进合适的位置 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, a[i], i &lt; n - 1 ? &#39; &#39; : &#39;\n&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, i;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    int* a &#x3D; (int*)malloc(sizeof(int)*n);</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    InsertionSort(a, n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Typhoonix/CDN-for-blog@1.15/images/%E6%8E%92%E5%BA%8Fblog/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4.png" alt="运行结果图"></p></li><li><p>希尔排序</p></li></ol><p>Sedgewick增量序列以外还有其他序列可用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*PTA运行成功*&#x2F;</span><br><span class="line">void ShellSort(int A[], int N)</span><br><span class="line">&#123; &#x2F;* 希尔排序 - 用Sedgewick增量序列 *&#x2F;</span><br><span class="line">    int Si, D, P, i;</span><br><span class="line">    int Tmp;</span><br><span class="line">    &#x2F;* 这里只列出一小部分增量 *&#x2F;</span><br><span class="line">    int Sedgewick[] &#x3D; &#123;929, 505, 209, 109, 41, 19, 5, 1, 0&#125;;</span><br><span class="line"></span><br><span class="line">    for (Si &#x3D; 0; Sedgewick[Si] &gt;&#x3D; N; Si++)</span><br><span class="line">        ; &#x2F;* 初始的增量Sedgewick[Si]不能超过待排序列长度 *&#x2F;</span><br><span class="line"></span><br><span class="line">    for (D &#x3D; Sedgewick[Si]; D &gt; 0; D &#x3D; Sedgewick[++Si])</span><br><span class="line">        for (P &#x3D; D; P &lt; N; P++)</span><br><span class="line">        &#123; &#x2F;* 插入排序, 将1改成D即可*&#x2F;</span><br><span class="line">            Tmp &#x3D; A[P];</span><br><span class="line">            for (i &#x3D; P; i &gt;&#x3D; D &amp;&amp; A[i - D] &gt; Tmp; i -&#x3D; D)</span><br><span class="line">                A[i] &#x3D; A[i - D];</span><br><span class="line">            A[i] &#x3D; Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    for (i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, A[i], i &lt; N - 1 ? &#39; &#39; : &#39;\n&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, i;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    int* a &#x3D; (int*)malloc(sizeof(int)*n);</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ShellSort(a, n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Typhoonix/CDN-for-blog@1.15/images/%E6%8E%92%E5%BA%8Fblog/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4.png" alt="运行结果图"></p><ol start="5"><li><p>堆排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*PTA运行成功*&#x2F;</span><br><span class="line">void Swap(int *a, int *b)</span><br><span class="line">&#123;</span><br><span class="line">    int t &#x3D; *a;</span><br><span class="line">    *a &#x3D; *b;</span><br><span class="line">    *b &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PercDown(int A[], int p, int N)</span><br><span class="line">&#123;   &#x2F;* 改编代码4.24的PercDown( MaxHeap H, int p ) *&#x2F;</span><br><span class="line">    &#x2F;* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 *&#x2F;</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    int X;</span><br><span class="line"></span><br><span class="line">    X &#x3D; A[p]; &#x2F;* 取出根结点存放的值 *&#x2F;</span><br><span class="line">    for (Parent &#x3D; p; (Parent * 2 + 1) &lt; N; Parent &#x3D; Child)</span><br><span class="line">    &#123;</span><br><span class="line">        Child &#x3D; Parent * 2 + 1;</span><br><span class="line">        if ((Child !&#x3D; N - 1) &amp;&amp; (A[Child] &lt; A[Child + 1]))</span><br><span class="line">            Child++; &#x2F;* Child指向左右子结点的较大者 *&#x2F;</span><br><span class="line">        if (X &gt;&#x3D; A[Child])</span><br><span class="line">            break; &#x2F;* 找到了合适位置 *&#x2F;</span><br><span class="line">        else       &#x2F;* 下滤X *&#x2F;</span><br><span class="line">            A[Parent] &#x3D; A[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    A[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Heap_Sort(int A[], int N)</span><br><span class="line">&#123; &#x2F;* 堆排序 *&#x2F;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; N &#x2F; 2 - 1; i &gt;&#x3D; 0; i--) &#x2F;* 建立最大堆 *&#x2F;</span><br><span class="line">        PercDown(A, i, N);</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; N - 1; i &gt; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;* 删除最大堆顶 *&#x2F;</span><br><span class="line">        Swap(&amp;A[0], &amp;A[i]); &#x2F;* 见代码7.1 *&#x2F;</span><br><span class="line">        PercDown(A, 0, i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, A[i], i &lt; N - 1 ? &#39; &#39; : &#39;\n&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, i;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    int* a &#x3D; (int*)malloc(sizeof(int)*n);</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Heap_Sort(a, n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Typhoonix/CDN-for-blog@1.15/images/%E6%8E%92%E5%BA%8Fblog/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4.png" alt="运行结果图"></p></li><li><p>归并排序</p></li></ol><ul><li><p>递归法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">&#x2F;*PTA运行成功*&#x2F;</span><br><span class="line">&#x2F;* 归并排序 - 递归实现 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* L &#x3D; 左边起始位置, R &#x3D; 右边起始位置, RightEnd &#x3D; 右边终点位置*&#x2F;</span><br><span class="line">void Merge(int A[], int TmpA[], int L, int R, int RightEnd)</span><br><span class="line">&#123; &#x2F;* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 *&#x2F;</span><br><span class="line">    int LeftEnd, NumElements, Tmp;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    LeftEnd &#x3D; R - 1; &#x2F;* 左边终点位置 *&#x2F;</span><br><span class="line">    Tmp &#x3D; L;         &#x2F;* 有序序列的起始位置 *&#x2F;</span><br><span class="line">    NumElements &#x3D; RightEnd - L + 1;</span><br><span class="line"></span><br><span class="line">    while (L &lt;&#x3D; LeftEnd &amp;&amp; R &lt;&#x3D; RightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        if (A[L] &lt;&#x3D; A[R])</span><br><span class="line">            TmpA[Tmp++] &#x3D; A[L++]; &#x2F;* 将左边元素复制到TmpA *&#x2F;</span><br><span class="line">        else</span><br><span class="line">            TmpA[Tmp++] &#x3D; A[R++]; &#x2F;* 将右边元素复制到TmpA *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (L &lt;&#x3D; LeftEnd)</span><br><span class="line">        TmpA[Tmp++] &#x3D; A[L++]; &#x2F;* 直接复制左边剩下的 *&#x2F;</span><br><span class="line">    while (R &lt;&#x3D; RightEnd)</span><br><span class="line">        TmpA[Tmp++] &#x3D; A[R++]; &#x2F;* 直接复制右边剩下的 *&#x2F;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; NumElements; i++, RightEnd--)</span><br><span class="line">        A[RightEnd] &#x3D; TmpA[RightEnd]; &#x2F;* 将有序的TmpA[]复制回A[] *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Msort(int A[], int TmpA[], int L, int RightEnd)</span><br><span class="line">&#123; &#x2F;* 核心递归排序函数 *&#x2F;</span><br><span class="line">    int Center;</span><br><span class="line"></span><br><span class="line">    if (L &lt; RightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        Center &#x3D; (L + RightEnd) &#x2F; 2;</span><br><span class="line">        Msort(A, TmpA, L, Center);               &#x2F;* 递归解决左边 *&#x2F;</span><br><span class="line">        Msort(A, TmpA, Center + 1, RightEnd);    &#x2F;* 递归解决右边 *&#x2F;</span><br><span class="line">        Merge(A, TmpA, L, Center + 1, RightEnd); &#x2F;* 合并两段有序序列 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge_Sort(int A[], int N)</span><br><span class="line">&#123; &#x2F;* 归并排序 *&#x2F;</span><br><span class="line">    int *TmpA, i;</span><br><span class="line">    TmpA &#x3D; (int *)malloc(N * sizeof(int));</span><br><span class="line"></span><br><span class="line">    if (TmpA !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Msort(A, TmpA, 0, N - 1);</span><br><span class="line">        free(TmpA);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;空间不足&quot;);</span><br><span class="line">    for (i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, A[i], i &lt; N - 1 ? &#39; &#39; : &#39;\n&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, i;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    int* a &#x3D; (int*)malloc(sizeof(int)*n);</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Merge_Sort(a, n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Typhoonix/CDN-for-blog@1.15/images/%E6%8E%92%E5%BA%8Fblog/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4.png" alt="运行结果图"></p></li><li><p>非递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">&#x2F;*PTA运行成功*&#x2F;</span><br><span class="line">void Merge(int A[], int TmpA[], int L, int R, int RightEnd)</span><br><span class="line">&#123; &#x2F;* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 *&#x2F;</span><br><span class="line">    int LeftEnd, NumElements, Tmp;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    LeftEnd &#x3D; R - 1; &#x2F;* 左边终点位置 *&#x2F;</span><br><span class="line">    Tmp &#x3D; L;         &#x2F;* 有序序列的起始位置 *&#x2F;</span><br><span class="line">    NumElements &#x3D; RightEnd - L + 1;</span><br><span class="line"></span><br><span class="line">    while (L &lt;&#x3D; LeftEnd &amp;&amp; R &lt;&#x3D; RightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        if (A[L] &lt;&#x3D; A[R])</span><br><span class="line">            TmpA[Tmp++] &#x3D; A[L++]; &#x2F;* 将左边元素复制到TmpA *&#x2F;</span><br><span class="line">        else</span><br><span class="line">            TmpA[Tmp++] &#x3D; A[R++]; &#x2F;* 将右边元素复制到TmpA *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (L &lt;&#x3D; LeftEnd)</span><br><span class="line">        TmpA[Tmp++] &#x3D; A[L++]; &#x2F;* 直接复制左边剩下的 *&#x2F;</span><br><span class="line">    while (R &lt;&#x3D; RightEnd)</span><br><span class="line">        TmpA[Tmp++] &#x3D; A[R++]; &#x2F;* 直接复制右边剩下的 *&#x2F;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; NumElements; i++, RightEnd--)</span><br><span class="line">        A[RightEnd] &#x3D; TmpA[RightEnd]; &#x2F;* 将有序的TmpA[]复制回A[] *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 归并排序 - 循环实现 *&#x2F;</span><br><span class="line">&#x2F;* 这里Merge函数在递归版本中给出 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* length &#x3D; 当前有序子列的长度*&#x2F;</span><br><span class="line">void Merge_pass(int A[], int TmpA[], int N, int length)</span><br><span class="line">&#123; &#x2F;* 两两归并相邻有序子列 *&#x2F;</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt;&#x3D; N - 2 * length; i +&#x3D; 2 * length)</span><br><span class="line">        Merge(A, TmpA, i, i + length, i + 2 * length - 1);</span><br><span class="line">    if (i + length &lt; N) &#x2F;* 归并最后2个子列*&#x2F;</span><br><span class="line">        Merge(A, TmpA, i, i + length, N - 1);</span><br><span class="line">    else &#x2F;* 最后只剩1个子列*&#x2F;</span><br><span class="line">        for (j &#x3D; i; j &lt; N; j++)</span><br><span class="line">            TmpA[j] &#x3D; A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge_Sort(int A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    int length, i;</span><br><span class="line">    int *TmpA;</span><br><span class="line"></span><br><span class="line">    length &#x3D; 1; &#x2F;* 初始化子序列长度*&#x2F;</span><br><span class="line">    TmpA &#x3D; malloc(N * sizeof(int));</span><br><span class="line">    if (TmpA !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        while (length &lt; N)</span><br><span class="line">        &#123;</span><br><span class="line">            Merge_pass(A, TmpA, N, length);</span><br><span class="line">            length *&#x3D; 2;</span><br><span class="line">            Merge_pass(TmpA, A, N, length);</span><br><span class="line">            length *&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        free(TmpA);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;空间不足&quot;);</span><br><span class="line">    for (i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, A[i], i &lt; N - 1 ? &#39; &#39; : &#39;\n&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, i;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    int* a &#x3D; (int*)malloc(sizeof(int)*n);</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Merge_Sort(a, n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Typhoonix/CDN-for-blog@1.15/images/%E6%8E%92%E5%BA%8Fblog/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4.png" alt="运行结果图"></p></li></ul><ol start="7"><li>快速排序</li></ol><p>对Cutoff的5种不同取值：50、100、200、300、400等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">&#x2F;* 快速排序 *&#x2F;</span><br><span class="line"></span><br><span class="line">void Swap(int *a, int *b)</span><br><span class="line">&#123;</span><br><span class="line">    int t &#x3D; *a;</span><br><span class="line">    *a &#x3D; *b;</span><br><span class="line">    *b &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertionSort(int a[], int n)</span><br><span class="line">&#123; &#x2F;* 插入排序 *&#x2F;</span><br><span class="line">    int P, i;</span><br><span class="line">    int Tmp;</span><br><span class="line"></span><br><span class="line">    for (P &#x3D; 1; P &lt; n; P++)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp &#x3D; a[P]; &#x2F;* 取出未排序序列中的第一个元素*&#x2F;</span><br><span class="line">        for (i &#x3D; P; i &gt; 0 &amp;&amp; a[i - 1] &gt; Tmp; i--)</span><br><span class="line">            a[i] &#x3D; a[i - 1]; &#x2F;*依次与已排序序列中元素比较并右移*&#x2F;</span><br><span class="line">        a[i] &#x3D; Tmp;          &#x2F;* 放进合适的位置 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Median3(int A[], int Left, int Right)</span><br><span class="line">&#123;</span><br><span class="line">    int Center &#x3D; (Left + Right) &#x2F; 2;</span><br><span class="line">    if (A[Left] &gt; A[Center])</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Center]);</span><br><span class="line">    if (A[Left] &gt; A[Right])</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Right]);</span><br><span class="line">    if (A[Center] &gt; A[Right])</span><br><span class="line">        Swap(&amp;A[Center], &amp;A[Right]);</span><br><span class="line">    &#x2F;* 此时A[Left] &lt;&#x3D; A[Center] &lt;&#x3D; A[Right] *&#x2F;</span><br><span class="line">    Swap(&amp;A[Center], &amp;A[Right - 1]); &#x2F;* 将基准Pivot藏到右边*&#x2F;</span><br><span class="line">    &#x2F;* 只需要考虑A[Left+1] … A[Right-2] *&#x2F;</span><br><span class="line">    return A[Right - 1]; &#x2F;* 返回基准Pivot *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Qsort(int A[], int Left, int Right)</span><br><span class="line">&#123; &#x2F;* 核心递归函数 *&#x2F;</span><br><span class="line">    int Pivot, Cutoff, Low, High;</span><br><span class="line">    Cutoff &#x3D; 50;</span><br><span class="line">    &#x2F;*对Cutoff的5种不同取值：50、100、200、300、400等*&#x2F;</span><br><span class="line">    if (Cutoff &lt;&#x3D; Right - Left)</span><br><span class="line">    &#123;                                    &#x2F;* 如果序列元素充分多，进入快排 *&#x2F;</span><br><span class="line">        Pivot &#x3D; Median3(A, Left, Right); &#x2F;* 选基准 *&#x2F;</span><br><span class="line">        Low &#x3D; Left;</span><br><span class="line">        High &#x3D; Right - 1;</span><br><span class="line">        while (1)</span><br><span class="line">        &#123; &#x2F;*将序列中比基准小的移到基准左边，大的移到右边*&#x2F;</span><br><span class="line">            while (A[++Low] &lt; Pivot)</span><br><span class="line">                ;</span><br><span class="line">            while (A[--High] &gt; Pivot)</span><br><span class="line">                ;</span><br><span class="line">            if (Low &lt; High)</span><br><span class="line">                Swap(&amp;A[Low], &amp;A[High]);</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        Swap(&amp;A[Low], &amp;A[Right - 1]); &#x2F;* 将基准换到正确的位置 *&#x2F;</span><br><span class="line">        Qsort(A, Left, Low - 1);      &#x2F;* 递归解决左边 *&#x2F;</span><br><span class="line">        Qsort(A, Low + 1, Right);     &#x2F;* 递归解决右边 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        InsertionSort(A + Left, Right - Left + 1); &#x2F;* 元素太少，用简单排序 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void QuickSort(int A[], int N)</span><br><span class="line">&#123; &#x2F;* 统一接口 *&#x2F;</span><br><span class="line">    int i;</span><br><span class="line">    Qsort(A, 0, N - 1);</span><br><span class="line">    for (i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, A[i], i &lt; N - 1 ? &#39; &#39; : &#39;\n&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, i;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    int *a &#x3D; (int *)malloc(sizeof(int) * n);</span><br><span class="line">    for (i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    QuickSort(a, n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Typhoonix/CDN-for-blog@1.15/images/%E6%8E%92%E5%BA%8Fblog/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4.png" alt="运行结果图"></p><h2 id="各个排序算法的比较"><a href="#各个排序算法的比较" class="headerlink" title="各个排序算法的比较"></a>各个排序算法的比较</h2><p><img src="https://cdn.jsdelivr.net/gh/Typhoonix/CDN-for-blog@1.15/images/%E6%8E%92%E5%BA%8Fblog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA列出连通集</title>
      <link href="/2020/08/14/PTA%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/"/>
      <url>/2020/08/14/PTA%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>涉及BFS和DFS的一道基础遍历题，方便加深对BFS和DFS的理解</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第1行给出2个整数N( 0 &lt; N ≤ 10 )和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>按照”{ v<sub>1</sub>, v<sub>2</sub>, …, v<sub>k</sub> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><p>因为只会加入0到10个顶点，而且顶点从0到N-1编号，所以直接使用邻接矩阵，最大顶点数设10即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MAXN 10        &#x2F;* 最大顶点数 *&#x2F;</span><br><span class="line"></span><br><span class="line">int visited[MAXN];</span><br><span class="line"></span><br><span class="line">int G[MAXN][MAXN], Nv, Ne;</span><br><span class="line"></span><br><span class="line">void BuildGraph() &#123;</span><br><span class="line">    int i, j, v1, v2;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv);</span><br><span class="line">    for(i &#x3D; 0; i &lt; Nv; i++)</span><br><span class="line">        for(j &#x3D; 0; j &lt; Nv; j++)</span><br><span class="line">            G[i][j] &#x3D; 0;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Ne);</span><br><span class="line">    for(i &#x3D; 0; i &lt; Ne; i++) &#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;v1, &amp;v2);</span><br><span class="line">        G[v1][v2] &#x3D; 1;</span><br><span class="line">        G[v2][v1] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(int v) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    visited[v] &#x3D; 1;</span><br><span class="line">    printf(&quot;%d &quot;, v);</span><br><span class="line">    for(i &#x3D; 0; i &lt; Nv; i++) &#123;</span><br><span class="line">        if(!visited[i] &amp;&amp; G[v][i] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            DFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BFS(int s) &#123;</span><br><span class="line">    int queue[11];</span><br><span class="line">    int f &#x3D; 0, r &#x3D; 0;</span><br><span class="line">    int v, i;</span><br><span class="line">    queue[r++] &#x3D; s;</span><br><span class="line">    visited[s] &#x3D; 1;</span><br><span class="line">    printf(&quot;%d &quot;, s);</span><br><span class="line">    while(f !&#x3D; r) &#123;</span><br><span class="line">        v &#x3D; queue[f++];</span><br><span class="line">        for(i &#x3D; 0; i &lt; Nv; i++) &#123;</span><br><span class="line">            if(!visited[i] &amp;&amp; G[v][i] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                printf(&quot;%d &quot;, i);</span><br><span class="line">                visited[i] &#x3D; 1;</span><br><span class="line">                queue[r++] &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ClearNums() &#123;</span><br><span class="line">    memset(visited, 0, sizeof(visited));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i;</span><br><span class="line">    BuildGraph();</span><br><span class="line">    for(i &#x3D; 0; i &lt; Nv; i++) &#123;</span><br><span class="line">        if(!visited[i]) &#123;</span><br><span class="line">            printf(&quot;&#123; &quot;);</span><br><span class="line">            DFS(i);</span><br><span class="line">            printf(&quot;&#125;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ClearNums();</span><br><span class="line">    for(i &#x3D; 0; i &lt; Nv; i++) &#123;</span><br><span class="line">        if(!visited[i]) &#123;</span><br><span class="line">            printf(&quot;&#123; &quot;);</span><br><span class="line">            BFS(i);</span><br><span class="line">            printf(&quot;&#125;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA平衡二叉树的根</title>
      <link href="/2020/08/13/PTA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A0%B9/"/>
      <url>/2020/08/13/PTA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<p>涉及到左单旋、右单旋、左右双旋、右左双旋的操作，值得记录</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将给定的一系列数字插入初始为空的AVL树，请你输出最后生成的AVL树的根结点的值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行给出一个正整数N（≤20），随后一行给出N个不同的整数，其间以空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>在一行中输出顺序插入上述整数到一棵初始为空的AVL树后，该树的根结点的值。</p><h2 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br></pre></td></tr></table></figure><h2 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure><h2 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2"></a>输入样例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure><h2 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2"></a>输出样例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">88</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef int ElementType;</span><br><span class="line"></span><br><span class="line">typedef struct AVLNode *Position;</span><br><span class="line">typedef Position AVLTree; &#x2F;* AVL树类型 *&#x2F;</span><br><span class="line">struct AVLNode&#123;</span><br><span class="line">    ElementType Data; &#x2F;* 结点数据 *&#x2F;</span><br><span class="line">    AVLTree Left;     &#x2F;* 指向左子树 *&#x2F;</span><br><span class="line">    AVLTree Right;    &#x2F;* 指向右子树 *&#x2F;</span><br><span class="line">    int Height;       &#x2F;* 树高 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Max ( int a, int b )</span><br><span class="line">&#123;</span><br><span class="line">    return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetHeight( AVLTree A ) &#123;</span><br><span class="line">    if(A &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return A-&gt;Height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVLTree SingleLeftRotation ( AVLTree A )</span><br><span class="line">&#123; &#x2F;* 注意：A必须有一个左子结点B *&#x2F;</span><br><span class="line">  &#x2F;* 将A与B做左单旋，更新A与B的高度，返回新的根结点B *&#x2F;     </span><br><span class="line"> </span><br><span class="line">    AVLTree B &#x3D; A-&gt;Left;</span><br><span class="line">    A-&gt;Left &#x3D; B-&gt;Right;</span><br><span class="line">    B-&gt;Right &#x3D; A;</span><br><span class="line">    A-&gt;Height &#x3D; Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1;</span><br><span class="line">    B-&gt;Height &#x3D; Max( GetHeight(B-&gt;Left), A-&gt;Height ) + 1;</span><br><span class="line">  </span><br><span class="line">    return B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVLTree SingleRightRotation ( AVLTree A )</span><br><span class="line">&#123; &#x2F;* 注意：A必须有一个右子结点B *&#x2F;</span><br><span class="line">  &#x2F;* 将A与B做右单旋，更新A与B的高度，返回新的根结点B *&#x2F;</span><br><span class="line"></span><br><span class="line">    AVLTree B &#x3D; A-&gt;Right;</span><br><span class="line">    A-&gt;Right &#x3D; B-&gt;Left;</span><br><span class="line">    B-&gt;Left &#x3D; A;</span><br><span class="line">    A-&gt;Height &#x3D; Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1;</span><br><span class="line">    B-&gt;Height &#x3D; Max( GetHeight(B-&gt;Right), A-&gt;Height ) + 1;</span><br><span class="line"></span><br><span class="line">    return B;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">AVLTree DoubleLeftRightRotation ( AVLTree A )</span><br><span class="line">&#123; &#x2F;* 注意：A必须有一个左子结点B，且B必须有一个右子结点C *&#x2F;</span><br><span class="line">  &#x2F;* 将A、B与C做两次单旋，返回新的根结点C *&#x2F;</span><br><span class="line">     </span><br><span class="line">    &#x2F;* 将B与C做右单旋，C被返回 *&#x2F;</span><br><span class="line">    A-&gt;Left &#x3D; SingleRightRotation(A-&gt;Left);</span><br><span class="line">    &#x2F;* 将A与C做左单旋，C被返回 *&#x2F;</span><br><span class="line">    return SingleLeftRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVLTree DoubleRightLeftRotation ( AVLTree A )</span><br><span class="line">&#123; &#x2F;* 注意：A必须有一个左子结点B，且B必须有一个右子结点C *&#x2F;</span><br><span class="line">  &#x2F;* 将A、B与C做两次单旋，返回新的根结点C *&#x2F;</span><br><span class="line">     </span><br><span class="line">    &#x2F;* 将B与C做右单旋，C被返回 *&#x2F;</span><br><span class="line">    A-&gt;Right &#x3D; SingleLeftRotation(A-&gt;Right);</span><br><span class="line">    &#x2F;* 将A与C做左单旋，C被返回 *&#x2F;</span><br><span class="line">    return SingleRightRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVLTree Insert( AVLTree T, ElementType X )</span><br><span class="line">&#123; &#x2F;* 将X插入AVL树T中，并且返回调整后的AVL树 *&#x2F;</span><br><span class="line">    if ( !T ) &#123; &#x2F;* 若插入空树，则新建包含一个结点的树 *&#x2F;</span><br><span class="line">        T &#x3D; (AVLTree)malloc(sizeof(struct AVLNode));</span><br><span class="line">        T-&gt;Data &#x3D; X;</span><br><span class="line">        T-&gt;Height &#x3D; 0;</span><br><span class="line">        T-&gt;Left &#x3D; T-&gt;Right &#x3D; NULL;</span><br><span class="line">    &#125; &#x2F;* if (插入空树) 结束 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    else if ( X &lt; T-&gt;Data ) &#123;</span><br><span class="line">        &#x2F;* 插入T的左子树 *&#x2F;</span><br><span class="line">        T-&gt;Left &#x3D; Insert( T-&gt;Left, X);</span><br><span class="line">        &#x2F;* 如果需要左旋 *&#x2F;</span><br><span class="line">        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) &gt; 1 )</span><br><span class="line">            if ( X &lt; T-&gt;Left-&gt;Data ) </span><br><span class="line">               T &#x3D; SingleLeftRotation(T);      &#x2F;* 左单旋 *&#x2F;</span><br><span class="line">            else </span><br><span class="line">               T &#x3D; DoubleLeftRightRotation(T); &#x2F;* 左-右双旋 *&#x2F;</span><br><span class="line">    &#125; &#x2F;* else if (插入左子树) 结束 *&#x2F;</span><br><span class="line">     </span><br><span class="line">    else if ( X &gt; T-&gt;Data ) &#123;</span><br><span class="line">        &#x2F;* 插入T的右子树 *&#x2F;</span><br><span class="line">        T-&gt;Right &#x3D; Insert( T-&gt;Right, X );</span><br><span class="line">        &#x2F;* 如果需要右旋 *&#x2F;</span><br><span class="line">        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) &lt; -1 )</span><br><span class="line">            if ( X &gt; T-&gt;Right-&gt;Data ) </span><br><span class="line">               T &#x3D; SingleRightRotation(T);     &#x2F;* 右单旋 *&#x2F;</span><br><span class="line">            else </span><br><span class="line">               T &#x3D; DoubleRightLeftRotation(T); &#x2F;* 右-左双旋 *&#x2F;</span><br><span class="line">    &#125; &#x2F;* else if (插入右子树) 结束 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* else X &#x3D;&#x3D; T-&gt;Data，无须插入 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 别忘了更新树高 *&#x2F;</span><br><span class="line">    T-&gt;Height &#x3D; Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + 1;</span><br><span class="line">     </span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    AVLTree A &#x3D; NULL;</span><br><span class="line">    int height, X;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;height);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; height; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;X);</span><br><span class="line">        A &#x3D; Insert(A, X);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, A-&gt;Data);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA是否同一二叉搜索树</title>
      <link href="/2020/08/13/PTA%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2020/08/13/PTA%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>树的基本练习，算是吧。。。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。</p><p>简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct TreeNode *Tree;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int v;</span><br><span class="line">    Tree Left, Right;</span><br><span class="line">    int flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree NewNode(int V)</span><br><span class="line">&#123;</span><br><span class="line">    Tree T &#x3D; (Tree)malloc(sizeof(struct TreeNode));</span><br><span class="line">    T-&gt;v &#x3D; V;</span><br><span class="line">    T-&gt;Left &#x3D; T-&gt;Right &#x3D; NULL;</span><br><span class="line">    T-&gt;flag &#x3D; 0;</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree Insert(Tree T, int V) &#123;</span><br><span class="line">    if(!T)</span><br><span class="line">        T &#x3D; NewNode(V);</span><br><span class="line">    else &#123;</span><br><span class="line">        if(V &gt; T-&gt;v)</span><br><span class="line">            T-&gt;Right &#x3D; Insert(T-&gt;Right, V);</span><br><span class="line">        else</span><br><span class="line">            T-&gt;Left &#x3D; Insert(T-&gt;Left, V);</span><br><span class="line">    &#125;</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree MakeTree(int N)</span><br><span class="line">&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    int i, V;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;V);</span><br><span class="line">    T &#x3D; NewNode(V);</span><br><span class="line">    for(i &#x3D; 1; i &lt; N; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;V);</span><br><span class="line">        T &#x3D; Insert(T, V);</span><br><span class="line">    &#125;</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int check(Tree T, int V) &#123;</span><br><span class="line">    if(T-&gt;flag) &#123;</span><br><span class="line">        if(V &lt; T-&gt;v)</span><br><span class="line">            return check(T-&gt;Left, V);</span><br><span class="line">        else if(V &gt; T-&gt;v)</span><br><span class="line">            return check(T-&gt;Right, V);</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if(V &#x3D;&#x3D; T-&gt;v) &#123;</span><br><span class="line">            T-&gt;flag &#x3D; 1;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Judge(Tree T, int N) &#123;</span><br><span class="line">    int i, V, flag &#x3D; 0;     &#x2F;*flag &#x3D; 0代表目前还一致，1代表已经不一致*&#x2F;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;V);</span><br><span class="line">    if(V !&#x3D; T-&gt;v)</span><br><span class="line">        flag &#x3D; 1;</span><br><span class="line">    else</span><br><span class="line">        T-&gt;flag &#x3D; 1;</span><br><span class="line">    for(i &#x3D; 1; i &lt; N; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;V);</span><br><span class="line">        if((!flag) &amp;&amp; (!check(T, V)))</span><br><span class="line">            flag &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag)</span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">        return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ResetT(Tree T) &#123;</span><br><span class="line">    if(T-&gt;Left)</span><br><span class="line">        ResetT(T-&gt;Left);</span><br><span class="line">    if(T-&gt;Right)</span><br><span class="line">        ResetT(T-&gt;Right);</span><br><span class="line">    T-&gt;flag &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FreeTree(Tree T) &#123;</span><br><span class="line">    if(T-&gt;Left)</span><br><span class="line">        FreeTree(T-&gt;Left);</span><br><span class="line">    if(T-&gt;Right)</span><br><span class="line">        FreeTree(T-&gt;Right);</span><br><span class="line">    free(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, L, i;</span><br><span class="line">    Tree T;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    while(N) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;L);</span><br><span class="line">        T &#x3D; MakeTree(N);</span><br><span class="line">        for(i &#x3D; 0; i &lt; L; i++) &#123;</span><br><span class="line">            if(Judge(T, N)) &#123;</span><br><span class="line">                printf(&quot;Yes\n&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                printf(&quot;No\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            ResetT(T);   </span><br><span class="line">        &#125;</span><br><span class="line">        FreeTree(T);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树搜索树的操作集</title>
      <link href="/2020/08/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86/"/>
      <url>/2020/08/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>实现二叉搜索树的5种常用操作，C实现</p><a id="more"></a><h2 id="函数接口定义"><a href="#函数接口定义" class="headerlink" title="函数接口定义"></a>函数接口定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BinTree Insert( BinTree BST, ElementType X );</span><br><span class="line">BinTree Delete( BinTree BST, ElementType X );</span><br><span class="line">Position Find( BinTree BST, ElementType X );</span><br><span class="line">Position FindMin( BinTree BST );</span><br><span class="line">Position FindMax( BinTree BST );</span><br></pre></td></tr></table></figure><p>其中 <strong>BinTree</strong> 结构定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct TNode *Position;</span><br><span class="line">typedef Position BinTree;</span><br><span class="line">struct TNode&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>函数 <strong>Insert</strong> 将 <strong>X</strong> 插入二叉搜索树 <strong>BST</strong> 并返回结果树的根结点指针；</li><li>函数 <strong>Delete</strong> 将 <strong>X</strong> 从二叉搜索树 <strong>BST</strong> 中删除，并返回结果树的根结点指针；如果 <strong>X</strong> 不在树中，则打印一行 <strong>Not Found</strong> 并返回原树的根结点指针；</li><li>函数 <strong>Find</strong> 在二叉搜索树 <strong>BST</strong> 中找到 <strong>X</strong> ，返回该结点的指针；如果找不到则返回空指针；</li><li>函数 <strong>FindMin</strong> 返回二叉搜索树 <strong>BST</strong> 中最小元结点的指针；</li><li>函数 <strong>FindMax</strong> 返回二叉搜索树 <strong>BST</strong> 中最大元结点的指针。</li></ul><h2 id="裁判测试程序样例"><a href="#裁判测试程序样例" class="headerlink" title="裁判测试程序样例"></a>裁判测试程序样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int ElementType;</span><br><span class="line">typedef struct TNode *Position;</span><br><span class="line">typedef Position BinTree;</span><br><span class="line">struct TNode&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void PreorderTraversal( BinTree BT ); &#x2F;* 先序遍历，由裁判实现，细节不表 *&#x2F;</span><br><span class="line">void InorderTraversal( BinTree BT );  &#x2F;* 中序遍历，由裁判实现，细节不表 *&#x2F;</span><br><span class="line"></span><br><span class="line">BinTree Insert( BinTree BST, ElementType X );</span><br><span class="line">BinTree Delete( BinTree BST, ElementType X );</span><br><span class="line">Position Find( BinTree BST, ElementType X );</span><br><span class="line">Position FindMin( BinTree BST );</span><br><span class="line">Position FindMax( BinTree BST );</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    int N, i;</span><br><span class="line"></span><br><span class="line">    BST &#x3D; NULL;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    for ( i&#x3D;0; i&lt;N; i++ ) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;X);</span><br><span class="line">        BST &#x3D; Insert(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Preorder:&quot;); PreorderTraversal(BST); printf(&quot;\n&quot;);</span><br><span class="line">    MinP &#x3D; FindMin(BST);</span><br><span class="line">    MaxP &#x3D; FindMax(BST);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    for( i&#x3D;0; i&lt;N; i++ ) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;X);</span><br><span class="line">        Tmp &#x3D; Find(BST, X);</span><br><span class="line">        if (Tmp &#x3D;&#x3D; NULL) printf(&quot;%d is not found\n&quot;, X);</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;%d is found\n&quot;, Tmp-&gt;Data);</span><br><span class="line">            if (Tmp&#x3D;&#x3D;MinP) printf(&quot;%d is the smallest key\n&quot;, Tmp-&gt;Data);</span><br><span class="line">            if (Tmp&#x3D;&#x3D;MaxP) printf(&quot;%d is the largest key\n&quot;, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    for( i&#x3D;0; i&lt;N; i++ ) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;X);</span><br><span class="line">        BST &#x3D; Delete(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Inorder:&quot;); InorderTraversal(BST); printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 你的代码将被嵌在这里 *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">5 8 6 2 4 1 0 10 9 7</span><br><span class="line">5</span><br><span class="line">6 3 10 0 5</span><br><span class="line">5</span><br><span class="line">5 7 0 10 3</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Preorder: 5 2 1 0 4 8 6 7 10 9</span><br><span class="line">6 is found</span><br><span class="line">3 is not found</span><br><span class="line">10 is found</span><br><span class="line">10 is the largest key</span><br><span class="line">0 is found</span><br><span class="line">0 is the smallest key</span><br><span class="line">5 is found</span><br><span class="line">Not Found</span><br><span class="line">Inorder: 1 2 4 6 8 9</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Position Find( BinTree BST, ElementType X ) &#123;</span><br><span class="line">    while(BST) &#123;</span><br><span class="line">        if (X &gt; BST-&gt;Data) &#123;</span><br><span class="line">            BST &#x3D; BST-&gt;Right;</span><br><span class="line">        &#125; else if (X &lt; BST-&gt;Data) &#123;</span><br><span class="line">            BST &#x3D; BST-&gt;Left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return BST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">Position FindMin( BinTree BST ) &#123;</span><br><span class="line">    if(BST)</span><br><span class="line">    &#123;</span><br><span class="line">        while (BST-&gt;Left)</span><br><span class="line">        &#123;</span><br><span class="line">            BST &#x3D; BST-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br><span class="line">Position FindMax( BinTree BST ) &#123;</span><br><span class="line">    if(BST)</span><br><span class="line">    &#123;</span><br><span class="line">        while (BST-&gt;Right)</span><br><span class="line">        &#123;</span><br><span class="line">            BST &#x3D; BST-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br><span class="line">BinTree Insert( BinTree BST, ElementType X ) &#123;</span><br><span class="line">    if(!BST) &#123;</span><br><span class="line">        BST &#x3D; (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">        BST-&gt;Data &#x3D; X;</span><br><span class="line">        BST-&gt;Left &#x3D; BST-&gt;Right &#x3D; NULL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (X &lt; BST-&gt;Data) &#123;</span><br><span class="line">            BST-&gt;Left &#x3D; Insert(BST-&gt;Left, X);</span><br><span class="line">        &#125; else if(X &gt; BST-&gt;Data) &#123;</span><br><span class="line">            BST-&gt;Right &#x3D; Insert(BST-&gt;Right, X);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br><span class="line">BinTree Delete( BinTree BST, ElementType X ) &#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    if (!BST) &#123;</span><br><span class="line">        printf(&quot;Not Found\n&quot;);</span><br><span class="line">        return BST;</span><br><span class="line">    &#125;</span><br><span class="line">    if (X &lt; BST-&gt;Data) &#123;</span><br><span class="line">        BST-&gt;Left &#x3D; Delete(BST-&gt;Left, X);</span><br><span class="line">    &#125; else if (X &gt; BST-&gt;Data) &#123;</span><br><span class="line">        BST-&gt;Right &#x3D; Delete(BST-&gt;Right, X);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123;</span><br><span class="line">            Tmp &#x3D; FindMin(BST-&gt;Right);</span><br><span class="line">            BST-&gt;Data &#x3D; Tmp-&gt;Data;</span><br><span class="line">            BST-&gt;Right &#x3D; Delete(BST-&gt;Right, BST-&gt;Data);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Tmp &#x3D; BST;</span><br><span class="line">            if(!BST-&gt;Left) &#123;</span><br><span class="line">                BST &#x3D; BST-&gt;Right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                BST &#x3D; BST-&gt;Left;</span><br><span class="line">            &#125;</span><br><span class="line">            free(Tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树遍历</title>
      <link href="/2020/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
      <url>/2020/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>采用递归，不依赖队列的堆栈的四种遍历方法，适合拿来做PTA，C语言走起</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 先序遍历 *&#x2F;</span><br><span class="line">void PreOrderTraversal(BinTree BT) &#123;</span><br><span class="line">    if (BT) &#123;</span><br><span class="line">        printf(&quot; %c&quot;, BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);   &#x2F;&#x2F;递归用法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 中序遍历 *&#x2F;</span><br><span class="line">void InOrderTravelsal(BinTree BT) &#123;</span><br><span class="line">    if (BT) &#123;</span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        printf(&quot; %c&quot;, BT-&gt;Data);</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);   &#x2F;&#x2F;递归用法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 后序遍历 *&#x2F;</span><br><span class="line">void PostOrderTravelsal(BinTree BT) &#123;</span><br><span class="line">    if (BT) &#123;</span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);   &#x2F;&#x2F;递归用法</span><br><span class="line">        printf(&quot; %c&quot;, BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 层序遍历 *&#x2F;</span><br><span class="line">void LevelorderTraversal( BinTree BT ) &#123;</span><br><span class="line">    BinTree t[101];</span><br><span class="line">    int i, j;</span><br><span class="line">    i &#x3D; j &#x3D; 0;</span><br><span class="line">    t[0] &#x3D; BT;</span><br><span class="line">    while(BT) &#123;</span><br><span class="line">        if (BT-&gt;Left) &#123;</span><br><span class="line">            t[++i] &#x3D; BT-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        if (BT-&gt;Right) &#123;</span><br><span class="line">            t[++i] &#x3D; BT-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        BinTree temp &#x3D; t[j];</span><br><span class="line">        printf(&quot; %c&quot;, temp-&gt;Data);</span><br><span class="line">        if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        BT &#x3D; t[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA树的同构</title>
      <link href="/2020/08/13/PTA%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/"/>
      <url>/2020/08/13/PTA%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>树的操作，C语言实现，比较难理解的一道题- -|||</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p><p><img src="https://images.ptausercontent.com/28" alt="图1"></p><p><img src="https://images.ptausercontent.com/29" alt="图2"></p><p>现给定两棵树，请你判断它们是否是同构的。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p><h2 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">A 1 2</span><br><span class="line">B 3 4</span><br><span class="line">C 5 -</span><br><span class="line">D - -</span><br><span class="line">E 6 -</span><br><span class="line">G 7 -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line">8</span><br><span class="line">G - 4</span><br><span class="line">B 7 6</span><br><span class="line">F - -</span><br><span class="line">A 5 1</span><br><span class="line">H - -</span><br><span class="line">C 0 -</span><br><span class="line">D - -</span><br><span class="line">E 2 -</span><br></pre></td></tr></table></figure><h2 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2"></a>输入样例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">B 5 7</span><br><span class="line">F - -</span><br><span class="line">A 0 3</span><br><span class="line">C 6 -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G 4 -</span><br><span class="line">E 1 -</span><br><span class="line">8</span><br><span class="line">D 6 -</span><br><span class="line">B 5 -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C 0 2</span><br><span class="line">G - 3</span><br><span class="line">F - -</span><br><span class="line">A 1 4</span><br></pre></td></tr></table></figure><h2 id="输出样例1-1"><a href="#输出样例1-1" class="headerlink" title="输出样例1"></a>输出样例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MaxTree 10</span><br><span class="line">#define ElementType char</span><br><span class="line">#define Tree int</span><br><span class="line">#define Null -1</span><br><span class="line"> </span><br><span class="line">struct TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;T1[MaxTree], T2[MaxTree];</span><br><span class="line"> </span><br><span class="line">Tree BuildTree(struct TreeNode T[]);</span><br><span class="line">int Isomorphic(Tree R1, Tree R2);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Tree R1, R2;</span><br><span class="line">    R1 &#x3D; BuildTree(T1);</span><br><span class="line">    R2 &#x3D; BuildTree(T2);</span><br><span class="line">    if (Isomorphic(R1, R2))</span><br><span class="line">        printf(&quot;Yes\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;No\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Tree BuildTree(struct TreeNode T[])</span><br><span class="line">&#123;</span><br><span class="line">    int N;</span><br><span class="line">    char cl, cr;</span><br><span class="line">    int check[MaxTree];       &#x2F;&#x2F; 判断每一个节点有没有节点指向</span><br><span class="line">    int Root&#x3D;Null;</span><br><span class="line">    scanf(&quot;%d\n&quot;, &amp;N);</span><br><span class="line">    if (N)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">            check[i] &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%c %c %c\n&quot;, &amp;T[i].Element, &amp;cl, &amp;cr);</span><br><span class="line">            if (cl !&#x3D; &#39;-&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                T[i].Left &#x3D; cl - &#39;0&#39;;</span><br><span class="line">                check[T[i].Left] &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                T[i].Left &#x3D; Null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cr !&#x3D; &#39;-&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                T[i].Right &#x3D; cr - &#39;0&#39;;</span><br><span class="line">                check[T[i].Right] &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                T[i].Right &#x3D; Null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!check[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Root &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Root;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int Isomorphic(Tree R1, Tree R2)</span><br><span class="line">&#123;</span><br><span class="line">    if (R1 &#x3D;&#x3D; Null &amp;&amp; R2 &#x3D;&#x3D; Null)</span><br><span class="line">        return 1;</span><br><span class="line">    if ((R1 &#x3D;&#x3D; Null &amp;&amp; R2 !&#x3D; Null) || (R2 !&#x3D; Null &amp;&amp; R1 &#x3D;&#x3D; Null))</span><br><span class="line">        return 0;</span><br><span class="line">    if (T1[R1].Element !&#x3D; T2[R2].Element)</span><br><span class="line">        return 0;</span><br><span class="line">    if ((T1[R1].Left &#x3D;&#x3D; Null) &amp;&amp; (T2[R2].Left &#x3D;&#x3D; Null))</span><br><span class="line">        return Isomorphic(T1[R1].Right, T2[R2].Right);</span><br><span class="line">    &#x2F;&#x2F; 不需要交换左右子树</span><br><span class="line">    if (((T1[R1].Left !&#x3D; Null) &amp;&amp; (T2[R2].Left !&#x3D; Null)) &amp;&amp;</span><br><span class="line">        ((T1[T1[R1].Left].Element) &#x3D;&#x3D; T2[T2[R2].Left].Element))</span><br><span class="line">    &#123;</span><br><span class="line">        return (Isomorphic(T1[R1].Left, T2[R2].Left))&amp;&amp;</span><br><span class="line">            (Isomorphic(T1[R1].Right, T2[R2].Right));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 需要交换左右子数</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return (Isomorphic(T1[R1].Left, T2[R2].Right)) &amp;&amp;</span><br><span class="line">            (Isomorphic(T1[R1].Right, T2[R2].Left));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一元多项式的乘法与加法运算</title>
      <link href="/2020/08/13/PTA%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E5%92%8C%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/"/>
      <url>/2020/08/13/PTA%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E5%92%8C%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>C语言数组暴力解法，这比课堂上那个简单粗暴多了，方便记忆</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计函数分别求两个一元多项式的乘积与和。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出 <strong>0 0</strong>。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><p>i作为数组1下标，j作为数组2下标，对应多项式幂，数组存的内容就是系数，注意输出格式就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;t1,t2分别为0次输入数据，t3为乘法结果，t4为加法结果</span><br><span class="line">int t1[1005], t2[1005], t3[2005], t4[1005];</span><br><span class="line">#define max 1000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出函数，arr为结果数组，range为最大范围。</span><br><span class="line">void show(int *arr, int range)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int tag &#x3D; 0;</span><br><span class="line">    for(i &#x3D; range; i &gt;&#x3D; 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr[i] !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;输出的第一项前面没有空格，通过tag进行判断。</span><br><span class="line">            if(tag)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            tag &#x3D; 1;</span><br><span class="line">            printf(&quot;%d %d&quot;, arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;若最终tag为0表示没有输出过，整个结果为0，输出0 0</span><br><span class="line">    if(!tag)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;0 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n1, n2, i, j, a, b;</span><br><span class="line">    &#x2F;&#x2F;数组置0</span><br><span class="line">    memset(t1, 0, sizeof(t1));</span><br><span class="line">    memset(t2, 0, sizeof(t2));</span><br><span class="line">    memset(t3, 0, sizeof(t3));</span><br><span class="line">    memset(t4, 0, sizeof(t4));</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n1);</span><br><span class="line">    for(i &#x3D; 0; i &lt; n1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);</span><br><span class="line">        t1[b] &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n2);</span><br><span class="line">    for(i &#x3D; 0; i &lt; n2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);</span><br><span class="line">        t2[b] &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;计算乘法</span><br><span class="line">    for(i &#x3D; 0; i &lt;&#x3D; max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j &#x3D; 0; j &lt;&#x3D; max; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            t3[i + j] +&#x3D; t1[i] * t2[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;计算加法</span><br><span class="line">    for(i &#x3D; 0; i &lt;&#x3D; max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t4[i] &#x3D; t1[i] + t2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;输出</span><br><span class="line">    show(t3, max * 2);</span><br><span class="line">    show(t4, max);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA两个有序链表序列的合并</title>
      <link href="/2020/08/12/PTA%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6/"/>
      <url>/2020/08/12/PTA%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<p>考察链表基本操作，C语言解法</p><a id="more"></a><p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。</p><h2 id="函数接口定义"><a href="#函数接口定义" class="headerlink" title="函数接口定义"></a>函数接口定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List Merge( List L1, List L2 );</span><br></pre></td></tr></table></figure><p>其中 <strong>List</strong> 结构定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node &#123;</span><br><span class="line">    ElementType Data; &#x2F;* 存储结点数据 *&#x2F;</span><br><span class="line">    PtrToNode   Next; &#x2F;* 指向下一个结点的指针 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode List; &#x2F;* 定义单链表类型 *&#x2F;</span><br></pre></td></tr></table></figure><p><strong>L1</strong> 和 <strong>L2</strong> 是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数 <strong>Merge</strong> 要将 <strong>L1</strong> 和 <strong>L2</strong> 合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p><h2 id="裁判测试程序样例"><a href="#裁判测试程序样例" class="headerlink" title="裁判测试程序样例"></a>裁判测试程序样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int ElementType;</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node &#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode List;</span><br><span class="line"></span><br><span class="line">List Read(); &#x2F;* 细节在此不表 *&#x2F;</span><br><span class="line">void Print( List L ); &#x2F;* 细节在此不表；空链表将输出NULL *&#x2F;</span><br><span class="line"></span><br><span class="line">List Merge( List L1, List L2 );</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 &#x3D; Read();</span><br><span class="line">    L2 &#x3D; Read();</span><br><span class="line">    L &#x3D; Merge(L1, L2);</span><br><span class="line">    Print(L);</span><br><span class="line">    Print(L1);</span><br><span class="line">    Print(L2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 你的代码将被嵌在这里 *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><p>pa遍历L1, pb遍历L2, pc作为桥梁构建合链L</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List Merge( List L1, List L2 ) &#123;</span><br><span class="line">    List pa, pb, pc, L;</span><br><span class="line">    L &#x3D; (List)malloc(sizeof(struct Node));</span><br><span class="line">    pa &#x3D; L1-&gt;Next;</span><br><span class="line">    pb &#x3D; L2-&gt;Next;</span><br><span class="line">    pc &#x3D; L;</span><br><span class="line">    while(pa &amp;&amp; pb) &#123;</span><br><span class="line">        if (pa-&gt;Data &lt;&#x3D; pb-&gt;Data) &#123;</span><br><span class="line">            pc-&gt;Next &#x3D; pa;</span><br><span class="line">            pc &#x3D; pa;</span><br><span class="line">            pa &#x3D; pa-&gt;Next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pc-&gt;Next &#x3D; pb;</span><br><span class="line">            pc &#x3D; pb;</span><br><span class="line">            pb &#x3D; pb-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;Next &#x3D; pa ? pa : pb;</span><br><span class="line">    L1-&gt;Next &#x3D; NULL;</span><br><span class="line">    L2-&gt;Next &#x3D; NULL;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA二分查找法</title>
      <link href="/2020/08/12/PTA%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
      <url>/2020/08/12/PTA%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>挺早学但好像挺重要的，姑且记录一下，还是C语言解法</p><a id="more"></a><p>本题要求实现二分查找算法。</p><h2 id="函数接口定义"><a href="#函数接口定义" class="headerlink" title="函数接口定义"></a>函数接口定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Position BinarySearch( List L, ElementType X );</span><br></pre></td></tr></table></figure><p>其中 <strong>List</strong> 结构定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef int Position;</span><br><span class="line">typedef struct LNode *List;</span><br><span class="line">struct LNode &#123;</span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; &#x2F;* 保存线性表中最后一个元素的位置 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>L</strong> 是用户传入的一个线性表，其中 <strong>ElementType</strong> 元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数 <strong>BinarySearch</strong> 要查找 <strong>X</strong> 在 <strong>Data</strong> 中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记 <strong>NotFound</strong></p><h2 id="裁判测试程序样例"><a href="#裁判测试程序样例" class="headerlink" title="裁判测试程序样例"></a>裁判测试程序样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 10</span><br><span class="line">#define NotFound 0</span><br><span class="line">typedef int ElementType;</span><br><span class="line"></span><br><span class="line">typedef int Position;</span><br><span class="line">typedef struct LNode *List;</span><br><span class="line">struct LNode &#123;</span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; &#x2F;* 保存线性表中最后一个元素的位置 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">List ReadInput(); &#x2F;* 裁判实现，细节不表。元素从下标1开始存储 *&#x2F;</span><br><span class="line">Position BinarySearch( List L, ElementType X );</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    L &#x3D; ReadInput();</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;X);</span><br><span class="line">    P &#x3D; BinarySearch( L, X );</span><br><span class="line">    printf(&quot;%d\n&quot;, P);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 你的代码将被嵌在这里 *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><p>注意一下数据格式就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Position BinarySearch( List L, ElementType X ) &#123;</span><br><span class="line">    int low, high, mid;</span><br><span class="line">    low &#x3D; 0;</span><br><span class="line">    high &#x3D; L-&gt;Last;</span><br><span class="line">    while (low &lt;&#x3D; high) &#123;</span><br><span class="line">        mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">        if(X &#x3D;&#x3D; L-&gt;Data[mid]) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(X &lt; L-&gt;Data[mid]) &#123;</span><br><span class="line">            high &#x3D; mid - 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            low &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NotFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaximumSubsequenceSum解法</title>
      <link href="/2020/08/12/MaximumSubsequenceSum%E8%A7%A3%E6%B3%95/"/>
      <url>/2020/08/12/MaximumSubsequenceSum%E8%A7%A3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>最大子列和问题的变种，无非就是多加了找出最大子列和的第一个元素和最后一个元素</p><a id="more"></a><p>特点是在MaxSum更新的时候通过LastTag存入目前加上的数组元素的下标，从而找到最大子列和最后一个元素的下标，再倒推过来找到最大子列和的第一个元素的下标，存入FirstTag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int N, sum, FirstTag, LastTag, ThisSum, MaxSum, j, flag;</span><br><span class="line">    flag &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入数字个数：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    int* A &#x3D; (int*)malloc(sizeof(int)*N);</span><br><span class="line">    printf(&quot;请输入%d个数字：&quot;, N);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    ThisSum &#x3D; MaxSum &#x3D; 0;</span><br><span class="line">    for (j &#x3D; 0;j &lt; N;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum +&#x3D; A[j];</span><br><span class="line">        if (ThisSum &gt; MaxSum) &#123;</span><br><span class="line">            MaxSum &#x3D; ThisSum;</span><br><span class="line">            LastTag &#x3D; j;</span><br><span class="line">        &#125; else if (ThisSum &lt; 0)</span><br><span class="line">            ThisSum &#x3D; 0;</span><br><span class="line">        if(A[j] &gt;&#x3D; 0) &#123;</span><br><span class="line">            flag &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum &#x3D; 0;</span><br><span class="line">    for(int l &#x3D; LastTag; l &gt;&#x3D; 0; l--) &#123;</span><br><span class="line">        sum +&#x3D; A[l];</span><br><span class="line">        if(sum &#x3D;&#x3D; MaxSum) &#123;</span><br><span class="line">            FirstTag &#x3D; l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(MaxSum) &#123;</span><br><span class="line">        printf(&quot;最大子序列和为%d\n&quot;, MaxSum);</span><br><span class="line">    &#125; else if(flag) &#123;</span><br><span class="line">        printf(&quot;最大子序列和为0\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;最大子列和第一个元素为%d, 最后一个元素为%d\n&quot;, A[FirstTag], A[LastTag]);</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA最大子列和问题</title>
      <link href="/2020/08/12/PTA%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/12/PTA%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>采用C语言解法，后续可能会补充其他语种的写法</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定K个整数组成的序列{ N<sub>1</sub>, N<sub>2</sub>, …, N<sub>K</sub> }，“连续子列”被定义为{ N<sub>i</sub>, N<sub>i+1</sub>, …, N<sub>j</sub> }，其中 1 ≤ i ≤ j ≤ K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p><p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p><ul><li>数据1：与样例等价，测试基本正确性;</li><li>数据2：102个随机整数;</li><li>数据3：103个随机整数;</li><li>数据4：104个随机整数;</li><li>数据5：105个随机整数;</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第1行给出正整数K ( ≤100000 )；第2行给出K个整数，其间以空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">-2 11 -4 13 -5 -2</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="C语言解法"><a href="#C语言解法" class="headerlink" title="C语言解法"></a>C语言解法</h2><p>遍历整个数组时，ThisSum作为遍历数组的和，MaxSum不断靠ThisSum更新和大小，ThisSum &lt; 0时ThisSum会清零</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define MAXN 100000    &#x2F;&#x2F;本题最大数据是十万</span><br><span class="line"></span><br><span class="line">int MaxSubSequenceSum(const int A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    int ThisSum, MaxSum, j;</span><br><span class="line">    ThisSum &#x3D; MaxSum &#x3D; 0;</span><br><span class="line">    for (j &#x3D; 0;j &lt; N;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum +&#x3D; A[j];</span><br><span class="line">        if (ThisSum &gt; MaxSum)</span><br><span class="line">            MaxSum &#x3D; ThisSum;</span><br><span class="line">        else if (ThisSum &lt; 0)</span><br><span class="line">            ThisSum &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return MaxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int K, i;</span><br><span class="line">    </span><br><span class="line">    scanf(&quot;%d&quot;, &amp;K);</span><br><span class="line">    int* a &#x3D; (int*)malloc(sizeof(int)*K);</span><br><span class="line">    for ( i &#x3D; 0; i &lt; K; i++ )</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    printf(&quot;%d&quot;, MaxSubSequenceSum( a, K ));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语格助词全解</title>
      <link href="/2020/08/12/%E6%97%A5%E8%AF%AD%E6%A0%BC%E5%8A%A9%E8%AF%8D%E5%85%A8%E8%A7%A3/"/>
      <url>/2020/08/12/%E6%97%A5%E8%AF%AD%E6%A0%BC%E5%8A%A9%E8%AF%8D%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>整理一下日语的所有格助词用法，例如常用的が、を、に</p><p>仅供参考，怎么理解还得靠自己</p><a id="more"></a><h2 id="什么是格助词？"><a href="#什么是格助词？" class="headerlink" title="什么是格助词？"></a>什么是格助词？</h2><p>表达单词和动词直接的逻辑关系</p><p>日文所有格助词：が　を　に　へ　と　で　から　より　まで</p><h2 id="が"><a href="#が" class="headerlink" title="が"></a>が</h2><ol><li>表示动作或状态的主题（主词）</li></ol><ul><li><p>例：雨が　降ります</p><p>  りんごが　美味しいで</p></li></ul><ol start="2"><li>表示能力或者好恶的「对象」</li></ol><ul><li><p>例：お金が　欲しいです</p><p>  テレビが　買いたいです</p><p>  ドイツ語が　できます</p></li></ul><ol start="3"><li>加在名词后面成为新名词</li></ol><ul><li>例：我が国</li></ul><h2 id="を"><a href="#を" class="headerlink" title="を"></a>を</h2><ol><li>表示动作的对象</li></ol><ul><li><p>例：水を　飲みます</p><p>  映画を　見ます</p></li></ul><ol start="2"><li>表示移动空间</li></ol><ul><li><p>例：階段を　上がります</p><p>  公園を　散歩します　-&gt;  公園で（で表示动作的场所）</p></li></ul><ol start="3"><li>表示某段时间</li></ol><ul><li>例：楽しい　時間を　過ごしました</li></ul><ol start="4"><li>表示离开的场所</li></ol><ul><li>例：電車を　おります</li></ul><ol start="5"><li>表示一种感动或者特别提出某一点来讲</li></ol><ul><li>例：お忙しところを、どうもすみません</li></ul><h2 id="に"><a href="#に" class="headerlink" title="に"></a>に</h2><ol><li>表示存在的场所</li></ol><ul><li>例：つくえをの　上に　ノートが　あります</li></ul><ol start="2"><li>表示动作的时间或顺序</li></ol><ul><li><p>例：十時に　いきます</p><p>  一週間に　三回　デートを　します（某段时间内的动作频率）</p></li></ul><ol start="3"><li>表示拥有者</li></ol><ul><li>例：私には　子供が　二人　います</li></ul><ol start="4"><li>表示动作主</li></ol><ul><li><p>例：私には　できません</p><p>  部下に　これを　やらせます（使役）</p><p>  先生に　叱られました（被动）</p></li></ul><ol start="5"><li>表示归属附着点</li></ol><ul><li><p>例：電車に　乗ります</p><p>  壁に　ポスターを　貼ります</p></li></ul><ol start="6"><li>表示变化结果</li></ol><ul><li><p>例：水が　氷に　おりました</p><p>  ～に　なります＝～で　ございます</p><p>  紅茶に　おります（您点的红茶）</p></li></ul><ol start="7"><li>东西的接受者/受惠者（间接对象）</li></ol><ul><li><p>例：子供に　おやつを　あげます</p><p>  恋人に　記念品を　買います</p></li></ul><ol start="8"><li>表示动作的对象（没有触及对方的抽象动作）</li></ol><ul><li><p>例：お客さんに　会います</p><p>  先生に　聞きます</p><p>  母に　何を　もらいます</p></li></ul><ol start="9"><li>对象抽象</li></ol><ul><li><p>例：あなたの　意見に　賛成します</p><p>  天文学に　詳しいですね</p></li></ul><ol start="10"><li>表示目的</li></ol><ul><li>例：新宿へ　買い物に　行きます</li></ul><ol start="11"><li>原因</li></ol><ul><li>例：勉強に　疲れました（心理）  -&gt;  勉強で　疲れました（生理）</li></ul><ol start="12"><li>附加</li></ol><ul><li>例：黒のスーツに　黒のネクタイの　男が　いる</li></ul><ol start="13"><li>表示动作的重复</li></ol><ul><li>例：走りに　走って　やっと　間に合いました</li></ul><h2 id="へ"><a href="#へ" class="headerlink" title="へ"></a>へ</h2><ol><li>动作方向</li></ol><ul><li><p>例：自宅へ　向かいます</p><p>  部屋へ　戻ります</p><p>  彼女への　プレゼントを　買います</p></li></ul><h2 id="と"><a href="#と" class="headerlink" title="と"></a>と</h2><ol><li>表示并列</li></ol><ul><li>例：教室に　山田さんと　林さんが　います</li></ul><ol start="2"><li>表示一起做某动作的对方</li></ol><ul><li>例：花子と　結婚しました</li></ul><ol start="3"><li>表示对称关系</li></ol><ul><li>例：以前と　違います</li></ul><ol start="4"><li>表示对话或思考的内容</li></ol><ul><li>例：安井さんも　行くと　言いましたよ</li></ul><ol start="5"><li>表示变化的结果</li></ol><ul><li><p>例：雪が　雨と　ありました</p><p>  塵も　積もれば　山と　なります</p></li></ul><ol start="6"><li>表示加强一种状态</li></ol><ul><li><p>例：うわさは　人から　人へと　伝わるものです</p><p>  あの選手は　小柄ながら　三位と　健闘しました</p><p>  ずっと　きっと　たっと　二度と</p></li></ul><h2 id="で"><a href="#で" class="headerlink" title="で"></a>で</h2><ol><li>表示动作的场所</li></ol><ul><li><p>例：教室で　勉強します</p><p>  教室の中で　弁当を　食べました</p></li></ul><ol start="2"><li>表示工具、方法、手段</li></ol><ul><li><p>例：自転車で　行きます</p><p>  鉛筆で　書きます</p></li></ul><ol start="3"><li>表示原因</li></ol><ul><li><p>例：風邪で　会社を　休みました</p><p>  寒さで　震えます</p></li></ul><ol start="4"><li>表示材料</li></ol><ul><li><p>例：紙で　飛行機を　作ります</p><p>  試験の結果で　判断します</p></li></ul><ol start="5"><li>表范围、限度</li></ol><ul><li><p>例：15人で　締め切ります</p><p>  一週間で　習得します</p></li></ul><ol start="6"><li>表示状态</li></ol><ul><li><p>例：今年で　二十歳に　なります</p><p>  大声で　叫びます</p></li></ul><ol start="7"><li>表动作者</li></ol><ul><li>例：みんあで　協力して　大会を　成功させましぃう</li></ul><ol start="8"><li>表示最低限度或方法</li></ol><ul><li>例：あなたの　そばに　いるだけで、幸せです</li></ul><h2 id="から（从……去……）"><a href="#から（从……去……）" class="headerlink" title="から（从……去……）"></a>から（从……去……）</h2><ol><li>表示动作或时间的起点</li></ol><ul><li><p>例：学校は　明日から　始まります</p><p>  大学から　でました（从大学走出来） -&gt; 大学を　出ました（从大学毕业）</p></li></ul><ol start="2"><li>表动作者</li></ol><ul><li>例：そのことは　私から　先生に　伝えますね</li></ul><ol start="3"><li>表示经过点</li></ol><ul><li>例：窓から　入りました</li></ul><ol start="4"><li>表示原因/理由/判断依据</li></ol><ul><li>例：別の立場から　考えます</li></ul><ol start="5"><li>表示原料（看不出原料的原样）-&gt; で（看得出原料）</li></ol><ul><li>例：酒は米から作られます</li></ul><ol start="6"><li>表示被动式里边的动作者</li></ol><ul><li><p>例：あの先生は　みんなから　尊敬されています</p><p>  このことは　同級生から　教えられました</p></li></ul><h2 id="まで"><a href="#まで" class="headerlink" title="まで"></a>まで</h2><ol><li>表示动作或者事情结束的时间跟地点</li></ol><ul><li><p>例：福岡まで　飛行機で　いきました</p><p>  仕事が　終わるまで　待ちましょう</p></li></ul><ol start="2"><li>用「～から　～まで」的句型表示明确的范围</li></ol><ul><li><p>例：仕事は　九時から　五時までです</p></li><li><p>不明确范围用「～から　～に　かけて」</p><ul><li>例：東京から　名古屋に　かけて　大雨の　恐れが　あります</li></ul></li></ul><ol start="3"><li>表最低限度，「连……都……」</li></ol><ul><li><p>例：雪まで降ってきた</p><p>  あなたが　泣きと、私もで　悲しく　なります</p></li></ul><h2 id="より"><a href="#より" class="headerlink" title="より"></a>より</h2><ol><li>比较/选择的对象</li></ol><ul><li><p>例：アメリカは　日本より　大きいです</p><p>  花より　団子</p></li></ul><ol start="2"><li>表示地点或者时间的起点</li></ol><ul><li><p>例：四時より　会議を　始めます</p><p>  遠方より　昔の友達が　やってきました</p></li></ul><ol start="3"><li>表示一种限定（除了……别的方法）</li></ol><ul><li>例：待つより　仕方が　ありません</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语动词变形方法全解</title>
      <link href="/2020/08/12/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/"/>
      <url>/2020/08/12/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>在学习日语的过程中动词变形还是比较难的一道坎，在此做一个整理。</p><a id="more"></a><h3 id="1、动词ます形变化规则"><a href="#1、动词ます形变化规则" class="headerlink" title="1、动词ます形变化规则"></a>1、动词ます形变化规则</h3><p>五段动词：将结尾假名变成它同行的前一个假名后+ます</p><ul><li>例：行く～行きます　　買う～買います</li></ul><p>一段动词：去る＋ます</p><ul><li>例：食べる～食べます　　起きる～起きます</li></ul><p>カ变动词：来（く）る～来（き）ます</p><p>サ变动词：する～します</p><ul><li>例：勉強する～勉強します</li><li>特殊五段动词：帰る～帰ります　　知る～知ります<br>　　　　　　　入る～入ります　　要る～要ります<br>　　　　　　　切る～切ります　　走る～走ります 等<h3 id="2、动词ない形"><a href="#2、动词ない形" class="headerlink" title="2、动词ない形"></a>2、动词ない形</h3></li></ul><p>五段动词：将结尾假名变成它同行的あ段上的假名后+ない。</p><ul><li>例：行く→行かない　　買う→買わない</li></ul><p>一段动词：去る+ない</p><ul><li>例：食べる→食べない　　起きる→起きない</li></ul><p>カ变动词：来る→来（こ）ない</p><p>サ变动词：する→しない</p><ul><li><p>例：勉強する→勉強しない</p></li><li><p>特殊五段动词：帰る→帰らない　　知る→知らない</p></li><li><p>其它的以此类推，将る变成ら+ない</p></li></ul><h3 id="3、动词可能形"><a href="#3、动词可能形" class="headerlink" title="3、动词可能形"></a>3、动词可能形</h3><p>五段动词：将结尾假名变成它同行的下一个假名后+る。</p><ul><li>例：行く→行ける　　買う→買える</li></ul><p>一段动词：去る+られる。</p><ul><li>例：食べる→食べられる　　起きる→起きられる</li></ul><p>カ变动词：来る→来（こ）られる</p><p>サ变动词：する→できる</p><ul><li>例：勉強する→勉強できる</li></ul><h3 id="4、动词て形"><a href="#4、动词て形" class="headerlink" title="4、动词て形"></a>4、动词て形</h3><p>五段动词：</p><p>く→いて　　ぐ→いで</p><ul><li>例：書く→書いて　脱ぐ→脱いで</li></ul><p>う、つ、る为结尾的，去掉う、つ、る＋って</p><ul><li>例：買う→買って　　立つ→立って　　終わる→終わって</li></ul><p>む、ぬ、ぶ为结尾的去掉+む、ぬ、ぶ＋んで　</p><ul><li>例：飲む→飲んで　　死ぬ→死んで　　飛ぶ→飛んで</li></ul><p>以す为结尾的す→して</p><ul><li>例：話す→話して</li></ul><p>一段动词：去る+て</p><ul><li>例：食べる→食べて　　起きる→起きて</li></ul><p>カ变动词：来る→来（き）て</p><p>サ变动词：する→して</p><ul><li>例：勉強する→勉強して</li><li>例外：行く→行って　　帰る→帰って　　知る→知って</li></ul><h3 id="5、假定形"><a href="#5、假定形" class="headerlink" title="5、假定形"></a>5、假定形</h3><p>五段动词：将结尾假名变成它同行的下一个假名后+ば</p><ul><li>例：行く→行けば　　買う→買えば</li></ul><p>一段动词：去る+れば</p><ul><li>例：食べる→食べれば　　起きる→起きれば</li></ul><p>カ变动词： 来る→来（く）れば</p><p>サ变动词： する→すれば</p><ul><li>例：散歩する→散歩すれば</li></ul><p>形容词：去い+ければ</p><ul><li>例：安い→安ければ　　おいしい→おいしければ</li></ul><p>形容动词：去だ+なら</p><ul><li>例：暇だ→暇なら　　簡単だ→簡単なら</li><li>名词：名词直接+なら</li><li>例：日本人→日本人なら</li></ul><h3 id="6、动词意向形"><a href="#6、动词意向形" class="headerlink" title="6、动词意向形"></a>6、动词意向形</h3><p>五段动词：将结尾假名变成它同行的最后一个假名后+う</p><ul><li>例：行く→行こう　　買う→買おう</li></ul><p>一段动词：去る+よう</p><ul><li>例：食べる→食べよう　　起きる→起きよう</li></ul><p>カ变动词： 来る→来（こ）よう</p><p>サ变动词： する→しよう</p><ul><li>例：散歩する→散歩しよう</li></ul><h3 id="7、动词命令形"><a href="#7、动词命令形" class="headerlink" title="7、动词命令形"></a>7、动词命令形</h3><p>五段动词：将结尾假名变成它同行的下一个假名即可.</p><ul><li>例：行く→行け　　買う→買え</li></ul><p>一段动词：去る+ろ</p><ul><li>例：起きる→起きろ　　食べる→食べろ</li></ul><p>カ变动词： 来る→来（こ）い</p><p>サ变动词： する→しろ/せよ</p><ul><li>例：勉強する→勉強しろ/せよ</li><li>动词禁止形是所有词的字典形（原形、基本形）+な</li><li>例：行く→行くな　　起きる→起きるな　　来る→来（く）るな　　勉強する→勉強するな</li></ul><h3 id="8、动词被动形"><a href="#8、动词被动形" class="headerlink" title="8、动词被动形"></a>8、动词被动形</h3><p>五段动词：将结尾假名变成它所在行的あ段上假名后+れる</p><ul><li>例：踏む→踏まれる　　呼ぶ→呼ばれる</li></ul><p>一段动词：去る+られる</p><ul><li>例：褒める→褒められる　　食べる→食べられる</li></ul><p>カ变动词： 来る→来（こ）られる</p><p>サ变动词： する→される</p><ul><li>例：発明する→発明される</li></ul><h3 id="9、动词使役形"><a href="#9、动词使役形" class="headerlink" title="9、动词使役形"></a>9、动词使役形</h3><p>五段动词：将结尾假名变成它所在行的あ段上假名后+せる。</p><ul><li>例：行く→行かせる　　飲む→飲ませる</li></ul><p>一段动词：去る+させる</p><ul><li>例：食べる→食べさせる　　起きる→起きさせる</li></ul><p>カ变动词： 来る→来（こ）させる</p><p>サ变动词： する→させる</p><ul><li>例：勉強する→勉強させる</li></ul><p><a href="https://jp.hjenglish.com/riyuyufa/p176653/">沪江日语原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 日语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2020/08/09/hello-world/"/>
      <url>/2020/08/09/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:50px;font-family:UD Digi Kyokasho NP-B"><center> A New Start </center></h1><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/Typhoonix/CDN-for-blog@1.12/images/wallpaper1.png" alt="夕陽を背にPixiv ID:70336750Member:みふる"></p><p>和其他大佬不一样，我是第一次搭建个人博客</p><p>多亏大佬们的博文，基于Github Page和hexo搭建的博客上手起来不难，不过还有很多细节需要慢慢添加调整，估计建起一个美观与实用兼顾的博客需要耗费不少精力 - -|||</p><p>回到博客这边，为什么要写博客，有以下好处：</p><ol><li>觉得懂未必懂，写作是一个很好的反思过程</li><li>好记性不如烂笔头，容易遗忘的知识点通过浏览写过的博客能快速重新掌握</li><li>结交志同道合的朋友，大佬之间经常通过博客作为交流渠道，不过目前这不是重点</li></ol><p>博客的内容大部分会记录我学过的一些知识、错题和遇到的种种BUG，如果学到了大体系的知识也会考虑记录进博客做整理</p><p>博客配置，主题采用volantis，使用github进行版本控制，后边可能会考虑用上coding</p><p>这是一次全新的开始，祝：</p><p>一路开心！</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
