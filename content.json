{"meta":{"title":"Typhoonix's Blog","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-08-10T08:36:14.799Z","updated":"2020-08-10T08:36:14.799Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2020-08-12T01:41:28.211Z","updated":"2020-08-12T01:41:28.211Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"广东工业大学，电子科学与技术本科在读 目前主要学习 Web前后端/硬件/日语/etc… 有开发游戏的小想法 核乐狗，主要偏向前卫金 不知何时能重操旧业的混音人"},{"title":"所有分类","date":"2020-08-11T07:56:45.199Z","updated":"2020-08-11T07:56:45.199Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-08-11T07:06:27.528Z","updated":"2020-08-11T07:06:27.528Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"下边是我的朋友或者一些大佬的博客链接(目前空缺中)","text":"下边是我的朋友或者一些大佬的博客链接(目前空缺中)"},{"title":"","date":"2020-08-10T08:35:32.071Z","updated":"2020-08-10T08:35:32.071Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-08-11T07:57:00.177Z","updated":"2020-08-11T07:57:00.177Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PTA平衡二叉树的根","slug":"PTA平衡二叉树的根","date":"2020-08-12T16:40:18.251Z","updated":"2020-08-12T16:43:41.255Z","comments":true,"path":"2020/08/13/PTA平衡二叉树的根/","link":"","permalink":"http://yoursite.com/2020/08/13/PTA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A0%B9/","excerpt":"涉及到左单旋、右单旋、左右双旋、右左双旋的操作，值得记录","text":"涉及到左单旋、右单旋、左右双旋、右左双旋的操作，值得记录 题目将给定的一系列数字插入初始为空的AVL树，请你输出最后生成的AVL树的根结点的值。 输入格式输入的第一行给出一个正整数N（≤20），随后一行给出N个不同的整数，其间以空格分隔。 输出格式在一行中输出顺序插入上述整数到一棵初始为空的AVL树后，该树的根结点的值。 输入样例112588 70 61 96 120 输出样例1170 输入样例212788 70 61 96 120 90 65 输出样例2188 C语言解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct AVLNode *Position;typedef Position AVLTree; &#x2F;* AVL树类型 *&#x2F;struct AVLNode&#123; ElementType Data; &#x2F;* 结点数据 *&#x2F; AVLTree Left; &#x2F;* 指向左子树 *&#x2F; AVLTree Right; &#x2F;* 指向右子树 *&#x2F; int Height; &#x2F;* 树高 *&#x2F;&#125;;int Max ( int a, int b )&#123; return a &gt; b ? a : b;&#125;int GetHeight( AVLTree A ) &#123; if(A &#x3D;&#x3D; NULL) &#123; return 0; &#125; return A-&gt;Height;&#125;AVLTree SingleLeftRotation ( AVLTree A )&#123; &#x2F;* 注意：A必须有一个左子结点B *&#x2F; &#x2F;* 将A与B做左单旋，更新A与B的高度，返回新的根结点B *&#x2F; AVLTree B &#x3D; A-&gt;Left; A-&gt;Left &#x3D; B-&gt;Right; B-&gt;Right &#x3D; A; A-&gt;Height &#x3D; Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1; B-&gt;Height &#x3D; Max( GetHeight(B-&gt;Left), A-&gt;Height ) + 1; return B;&#125;AVLTree SingleRightRotation ( AVLTree A )&#123; &#x2F;* 注意：A必须有一个右子结点B *&#x2F; &#x2F;* 将A与B做右单旋，更新A与B的高度，返回新的根结点B *&#x2F; AVLTree B &#x3D; A-&gt;Right; A-&gt;Right &#x3D; B-&gt;Left; B-&gt;Left &#x3D; A; A-&gt;Height &#x3D; Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1; B-&gt;Height &#x3D; Max( GetHeight(B-&gt;Right), A-&gt;Height ) + 1; return B;&#125; AVLTree DoubleLeftRightRotation ( AVLTree A )&#123; &#x2F;* 注意：A必须有一个左子结点B，且B必须有一个右子结点C *&#x2F; &#x2F;* 将A、B与C做两次单旋，返回新的根结点C *&#x2F; &#x2F;* 将B与C做右单旋，C被返回 *&#x2F; A-&gt;Left &#x3D; SingleRightRotation(A-&gt;Left); &#x2F;* 将A与C做左单旋，C被返回 *&#x2F; return SingleLeftRotation(A);&#125;AVLTree DoubleRightLeftRotation ( AVLTree A )&#123; &#x2F;* 注意：A必须有一个左子结点B，且B必须有一个右子结点C *&#x2F; &#x2F;* 将A、B与C做两次单旋，返回新的根结点C *&#x2F; &#x2F;* 将B与C做右单旋，C被返回 *&#x2F; A-&gt;Right &#x3D; SingleLeftRotation(A-&gt;Right); &#x2F;* 将A与C做左单旋，C被返回 *&#x2F; return SingleRightRotation(A);&#125;AVLTree Insert( AVLTree T, ElementType X )&#123; &#x2F;* 将X插入AVL树T中，并且返回调整后的AVL树 *&#x2F; if ( !T ) &#123; &#x2F;* 若插入空树，则新建包含一个结点的树 *&#x2F; T &#x3D; (AVLTree)malloc(sizeof(struct AVLNode)); T-&gt;Data &#x3D; X; T-&gt;Height &#x3D; 0; T-&gt;Left &#x3D; T-&gt;Right &#x3D; NULL; &#125; &#x2F;* if (插入空树) 结束 *&#x2F; else if ( X &lt; T-&gt;Data ) &#123; &#x2F;* 插入T的左子树 *&#x2F; T-&gt;Left &#x3D; Insert( T-&gt;Left, X); &#x2F;* 如果需要左旋 *&#x2F; if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) &gt; 1 ) if ( X &lt; T-&gt;Left-&gt;Data ) T &#x3D; SingleLeftRotation(T); &#x2F;* 左单旋 *&#x2F; else T &#x3D; DoubleLeftRightRotation(T); &#x2F;* 左-右双旋 *&#x2F; &#125; &#x2F;* else if (插入左子树) 结束 *&#x2F; else if ( X &gt; T-&gt;Data ) &#123; &#x2F;* 插入T的右子树 *&#x2F; T-&gt;Right &#x3D; Insert( T-&gt;Right, X ); &#x2F;* 如果需要右旋 *&#x2F; if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) &lt; -1 ) if ( X &gt; T-&gt;Right-&gt;Data ) T &#x3D; SingleRightRotation(T); &#x2F;* 右单旋 *&#x2F; else T &#x3D; DoubleRightLeftRotation(T); &#x2F;* 右-左双旋 *&#x2F; &#125; &#x2F;* else if (插入右子树) 结束 *&#x2F; &#x2F;* else X &#x3D;&#x3D; T-&gt;Data，无须插入 *&#x2F; &#x2F;* 别忘了更新树高 *&#x2F; T-&gt;Height &#x3D; Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + 1; return T;&#125;int main() &#123; AVLTree A &#x3D; NULL; int height, X; scanf(&quot;%d&quot;, &amp;height); for(int i &#x3D; 0; i &lt; height; i++) &#123; scanf(&quot;%d&quot;, &amp;X); A &#x3D; Insert(A, X); &#125; printf(&quot;%d\\n&quot;, A-&gt;Data); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"PTA是否同一二叉搜索树","slug":"PTA是否同一二叉搜索树","date":"2020-08-12T16:32:03.807Z","updated":"2020-08-12T16:35:16.324Z","comments":true,"path":"2020/08/13/PTA是否同一二叉搜索树/","link":"","permalink":"http://yoursite.com/2020/08/13/PTA%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"树的基本练习，算是吧。。。","text":"树的基本练习，算是吧。。。 题目给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。 输入格式输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。 简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。 输出格式对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。 输入样例123456784 23 1 4 23 4 1 23 2 4 12 12 11 20 输出样例123YesNoNo C语言解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct TreeNode *Tree;struct TreeNode &#123; int v; Tree Left, Right; int flag;&#125;;Tree NewNode(int V)&#123; Tree T &#x3D; (Tree)malloc(sizeof(struct TreeNode)); T-&gt;v &#x3D; V; T-&gt;Left &#x3D; T-&gt;Right &#x3D; NULL; T-&gt;flag &#x3D; 0; return T;&#125;Tree Insert(Tree T, int V) &#123; if(!T) T &#x3D; NewNode(V); else &#123; if(V &gt; T-&gt;v) T-&gt;Right &#x3D; Insert(T-&gt;Right, V); else T-&gt;Left &#x3D; Insert(T-&gt;Left, V); &#125; return T;&#125;Tree MakeTree(int N)&#123; Tree T; int i, V; scanf(&quot;%d&quot;, &amp;V); T &#x3D; NewNode(V); for(i &#x3D; 1; i &lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;V); T &#x3D; Insert(T, V); &#125; return T;&#125;int check(Tree T, int V) &#123; if(T-&gt;flag) &#123; if(V &lt; T-&gt;v) return check(T-&gt;Left, V); else if(V &gt; T-&gt;v) return check(T-&gt;Right, V); else return 0; &#125; else &#123; if(V &#x3D;&#x3D; T-&gt;v) &#123; T-&gt;flag &#x3D; 1; return 1; &#125; else &#123; return 0; &#125; &#125;&#125;int Judge(Tree T, int N) &#123; int i, V, flag &#x3D; 0; &#x2F;*flag &#x3D; 0代表目前还一致，1代表已经不一致*&#x2F; scanf(&quot;%d&quot;, &amp;V); if(V !&#x3D; T-&gt;v) flag &#x3D; 1; else T-&gt;flag &#x3D; 1; for(i &#x3D; 1; i &lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;V); if((!flag) &amp;&amp; (!check(T, V))) flag &#x3D; 1; &#125; if(flag) return 0; else return 1;&#125;void ResetT(Tree T) &#123; if(T-&gt;Left) ResetT(T-&gt;Left); if(T-&gt;Right) ResetT(T-&gt;Right); T-&gt;flag &#x3D; 0;&#125;void FreeTree(Tree T) &#123; if(T-&gt;Left) FreeTree(T-&gt;Left); if(T-&gt;Right) FreeTree(T-&gt;Right); free(T);&#125;int main() &#123; int N, L, i; Tree T; scanf(&quot;%d&quot;, &amp;N); while(N) &#123; scanf(&quot;%d&quot;, &amp;L); T &#x3D; MakeTree(N); for(i &#x3D; 0; i &lt; L; i++) &#123; if(Judge(T, N)) &#123; printf(&quot;Yes\\n&quot;); &#125; else &#123; printf(&quot;No\\n&quot;); &#125; ResetT(T); &#125; FreeTree(T); scanf(&quot;%d&quot;, &amp;N); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"二叉树搜索树的操作集","slug":"二叉搜索树的操作集","date":"2020-08-12T16:24:21.011Z","updated":"2020-08-12T16:29:16.354Z","comments":true,"path":"2020/08/13/二叉搜索树的操作集/","link":"","permalink":"http://yoursite.com/2020/08/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86/","excerpt":"实现二叉搜索树的5种常用操作，C实现","text":"实现二叉搜索树的5种常用操作，C实现 函数接口定义12345BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST ); 其中 BinTree 结构定义如下 1234567typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;; 函数 Insert 将 X 插入二叉搜索树 BST 并返回结果树的根结点指针； 函数 Delete 将 X 从二叉搜索树 BST 中删除，并返回结果树的根结点指针；如果 X 不在树中，则打印一行 Not Found 并返回原树的根结点指针； 函数 Find 在二叉搜索树 BST 中找到 X ，返回该结点的指针；如果找不到则返回空指针； 函数 FindMin 返回二叉搜索树 BST 中最小元结点的指针； 函数 FindMax 返回二叉搜索树 BST 中最大元结点的指针。 裁判测试程序样例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;;void PreorderTraversal( BinTree BT ); &#x2F;* 先序遍历，由裁判实现，细节不表 *&#x2F;void InorderTraversal( BinTree BT ); &#x2F;* 中序遍历，由裁判实现，细节不表 *&#x2F;BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST );int main()&#123; BinTree BST, MinP, MaxP, Tmp; ElementType X; int N, i; BST &#x3D; NULL; scanf(&quot;%d&quot;, &amp;N); for ( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); BST &#x3D; Insert(BST, X); &#125; printf(&quot;Preorder:&quot;); PreorderTraversal(BST); printf(&quot;\\n&quot;); MinP &#x3D; FindMin(BST); MaxP &#x3D; FindMax(BST); scanf(&quot;%d&quot;, &amp;N); for( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); Tmp &#x3D; Find(BST, X); if (Tmp &#x3D;&#x3D; NULL) printf(&quot;%d is not found\\n&quot;, X); else &#123; printf(&quot;%d is found\\n&quot;, Tmp-&gt;Data); if (Tmp&#x3D;&#x3D;MinP) printf(&quot;%d is the smallest key\\n&quot;, Tmp-&gt;Data); if (Tmp&#x3D;&#x3D;MaxP) printf(&quot;%d is the largest key\\n&quot;, Tmp-&gt;Data); &#125; &#125; scanf(&quot;%d&quot;, &amp;N); for( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); BST &#x3D; Delete(BST, X); &#125; printf(&quot;Inorder:&quot;); InorderTraversal(BST); printf(&quot;\\n&quot;); return 0;&#125;&#x2F;* 你的代码将被嵌在这里 *&#x2F; 输入样例123456105 8 6 2 4 1 0 10 9 756 3 10 0 555 7 0 10 3 输出样例12345678910Preorder: 5 2 1 0 4 8 6 7 10 96 is found3 is not found10 is found10 is the largest key0 is found0 is the smallest key5 is foundNot FoundInorder: 1 2 4 6 8 9 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Position Find( BinTree BST, ElementType X ) &#123; while(BST) &#123; if (X &gt; BST-&gt;Data) &#123; BST &#x3D; BST-&gt;Right; &#125; else if (X &lt; BST-&gt;Data) &#123; BST &#x3D; BST-&gt;Left; &#125; else &#123; return BST; &#125; &#125; return NULL;&#125;Position FindMin( BinTree BST ) &#123; if(BST) &#123; while (BST-&gt;Left) &#123; BST &#x3D; BST-&gt;Left; &#125; &#125; return BST;&#125;Position FindMax( BinTree BST ) &#123; if(BST) &#123; while (BST-&gt;Right) &#123; BST &#x3D; BST-&gt;Right; &#125; &#125; return BST;&#125;BinTree Insert( BinTree BST, ElementType X ) &#123; if(!BST) &#123; BST &#x3D; (BinTree)malloc(sizeof(struct TNode)); BST-&gt;Data &#x3D; X; BST-&gt;Left &#x3D; BST-&gt;Right &#x3D; NULL; &#125; else &#123; if (X &lt; BST-&gt;Data) &#123; BST-&gt;Left &#x3D; Insert(BST-&gt;Left, X); &#125; else if(X &gt; BST-&gt;Data) &#123; BST-&gt;Right &#x3D; Insert(BST-&gt;Right, X); &#125; &#125; return BST;&#125;BinTree Delete( BinTree BST, ElementType X ) &#123; Position Tmp; if (!BST) &#123; printf(&quot;Not Found\\n&quot;); return BST; &#125; if (X &lt; BST-&gt;Data) &#123; BST-&gt;Left &#x3D; Delete(BST-&gt;Left, X); &#125; else if (X &gt; BST-&gt;Data) &#123; BST-&gt;Right &#x3D; Delete(BST-&gt;Right, X); &#125; else &#123; if (BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; Tmp &#x3D; FindMin(BST-&gt;Right); BST-&gt;Data &#x3D; Tmp-&gt;Data; BST-&gt;Right &#x3D; Delete(BST-&gt;Right, BST-&gt;Data); &#125; else &#123; Tmp &#x3D; BST; if(!BST-&gt;Left) &#123; BST &#x3D; BST-&gt;Right; &#125; else &#123; BST &#x3D; BST-&gt;Left; &#125; free(Tmp); &#125; &#125; return BST;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"二叉树遍历","slug":"二叉树遍历","date":"2020-08-12T16:16:47.497Z","updated":"2020-08-12T16:19:37.291Z","comments":true,"path":"2020/08/13/二叉树遍历/","link":"","permalink":"http://yoursite.com/2020/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/","excerpt":"采用递归，不依赖队列的堆栈的四种遍历方法，适合拿来做PTA，C语言走起","text":"采用递归，不依赖队列的堆栈的四种遍历方法，适合拿来做PTA，C语言走起 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;* 先序遍历 *&#x2F;void PreOrderTraversal(BinTree BT) &#123; if (BT) &#123; printf(&quot; %c&quot;, BT-&gt;Data); PreOrderTraversal(BT-&gt;Left); PreOrderTraversal(BT-&gt;Right); &#x2F;&#x2F;递归用法 &#125;&#125;&#x2F;* 中序遍历 *&#x2F;void InOrderTravelsal(BinTree BT) &#123; if (BT) &#123; InOrderTraversal(BT-&gt;Left); printf(&quot; %c&quot;, BT-&gt;Data); InOrderTraversal(BT-&gt;Right); &#x2F;&#x2F;递归用法 &#125;&#125;&#x2F;* 后序遍历 *&#x2F;void PostOrderTravelsal(BinTree BT) &#123; if (BT) &#123; PostOrderTraversal(BT-&gt;Left); PostOrderTraversal(BT-&gt;Right); &#x2F;&#x2F;递归用法 printf(&quot; %c&quot;, BT-&gt;Data); &#125;&#125;&#x2F;* 层序遍历 *&#x2F;void LevelorderTraversal( BinTree BT ) &#123; BinTree t[101]; int i, j; i &#x3D; j &#x3D; 0; t[0] &#x3D; BT; while(BT) &#123; if (BT-&gt;Left) &#123; t[++i] &#x3D; BT-&gt;Left; &#125; if (BT-&gt;Right) &#123; t[++i] &#x3D; BT-&gt;Right; &#125; BinTree temp &#x3D; t[j]; printf(&quot; %c&quot;, temp-&gt;Data); if (i &#x3D;&#x3D; j) &#123; break; &#125; j++; BT &#x3D; t[j]; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"PTA树的同构","slug":"PTA树的同构","date":"2020-08-12T16:07:21.361Z","updated":"2020-08-12T16:13:15.599Z","comments":true,"path":"2020/08/13/PTA树的同构/","link":"","permalink":"http://yoursite.com/2020/08/13/PTA%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/","excerpt":"树的操作，C语言实现，比较难理解的一道题- -|||","text":"树的操作，C语言实现，比较难理解的一道题- -||| 题目给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。 现给定两棵树，请你判断它们是否是同构的。 输入格式输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。 输出格式如果两棵树是同构的，输出“Yes”，否则输出“No”。 输入样例11234567891011121314151617188A 1 2B 3 4C 5 -D - -E 6 -G 7 -F - -H - -8G - 4B 7 6F - -A 5 1H - -C 0 -D - -E 2 - 输出样例11Yes 输入样例21234567891011121314151617188B 5 7F - -A 0 3C 6 -H - -D - -G 4 -E 1 -8D 6 -B 5 -E - -H - -C 0 2G - 3F - -A 1 4 输出样例11No C语言解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MaxTree 10#define ElementType char#define Tree int#define Null -1 struct TreeNode&#123; ElementType Element; Tree Left; Tree Right;&#125;T1[MaxTree], T2[MaxTree]; Tree BuildTree(struct TreeNode T[]);int Isomorphic(Tree R1, Tree R2);int main()&#123; Tree R1, R2; R1 &#x3D; BuildTree(T1); R2 &#x3D; BuildTree(T2); if (Isomorphic(R1, R2)) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); return 0;&#125; Tree BuildTree(struct TreeNode T[])&#123; int N; char cl, cr; int check[MaxTree]; &#x2F;&#x2F; 判断每一个节点有没有节点指向 int Root&#x3D;Null; scanf(&quot;%d\\n&quot;, &amp;N); if (N) &#123; for (int i &#x3D; 0; i &lt; N; i++) check[i] &#x3D; 0; for (int i &#x3D; 0; i &lt; N; i++) &#123; scanf(&quot;%c %c %c\\n&quot;, &amp;T[i].Element, &amp;cl, &amp;cr); if (cl !&#x3D; &#39;-&#39;) &#123; T[i].Left &#x3D; cl - &#39;0&#39;; check[T[i].Left] &#x3D; 1; &#125; else &#123; T[i].Left &#x3D; Null; &#125; if (cr !&#x3D; &#39;-&#39;) &#123; T[i].Right &#x3D; cr - &#39;0&#39;; check[T[i].Right] &#x3D; 1; &#125; else &#123; T[i].Right &#x3D; Null; &#125; &#125; for (int i &#x3D; 0; i &lt; N; i++) &#123; if (!check[i]) &#123; Root &#x3D; i; break; &#125; &#125; &#125; return Root;&#125; int Isomorphic(Tree R1, Tree R2)&#123; if (R1 &#x3D;&#x3D; Null &amp;&amp; R2 &#x3D;&#x3D; Null) return 1; if ((R1 &#x3D;&#x3D; Null &amp;&amp; R2 !&#x3D; Null) || (R2 !&#x3D; Null &amp;&amp; R1 &#x3D;&#x3D; Null)) return 0; if (T1[R1].Element !&#x3D; T2[R2].Element) return 0; if ((T1[R1].Left &#x3D;&#x3D; Null) &amp;&amp; (T2[R2].Left &#x3D;&#x3D; Null)) return Isomorphic(T1[R1].Right, T2[R2].Right); &#x2F;&#x2F; 不需要交换左右子树 if (((T1[R1].Left !&#x3D; Null) &amp;&amp; (T2[R2].Left !&#x3D; Null)) &amp;&amp; ((T1[T1[R1].Left].Element) &#x3D;&#x3D; T2[T2[R2].Left].Element)) &#123; return (Isomorphic(T1[R1].Left, T2[R2].Left))&amp;&amp; (Isomorphic(T1[R1].Right, T2[R2].Right)); &#125; &#x2F;&#x2F; 需要交换左右子数 else &#123; return (Isomorphic(T1[R1].Left, T2[R2].Right)) &amp;&amp; (Isomorphic(T1[R1].Right, T2[R2].Left)); &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"一元多项式的乘法与加法运算","slug":"PTA一元多项式的乘法和加法运算","date":"2020-08-12T16:01:38.546Z","updated":"2020-08-12T16:20:24.127Z","comments":true,"path":"2020/08/13/PTA一元多项式的乘法和加法运算/","link":"","permalink":"http://yoursite.com/2020/08/13/PTA%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E5%92%8C%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/","excerpt":"C语言数组暴力解法，这比课堂上那个简单粗暴多了，方便记忆","text":"C语言数组暴力解法，这比课堂上那个简单粗暴多了，方便记忆 题目设计函数分别求两个一元多项式的乘积与和。 输入格式输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出 0 0。 输入样例124 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1 输出样例1215 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0 C语言解法i作为数组1下标，j作为数组2下标，对应多项式幂，数组存的内容就是系数，注意输出格式就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;string.h&gt;&#x2F;&#x2F;t1,t2分别为0次输入数据，t3为乘法结果，t4为加法结果int t1[1005], t2[1005], t3[2005], t4[1005];#define max 1000&#x2F;&#x2F;输出函数，arr为结果数组，range为最大范围。void show(int *arr, int range)&#123; int i; int tag &#x3D; 0; for(i &#x3D; range; i &gt;&#x3D; 0; --i) &#123; if(arr[i] !&#x3D; 0) &#123; &#x2F;&#x2F;输出的第一项前面没有空格，通过tag进行判断。 if(tag) &#123; printf(&quot; &quot;); &#125; tag &#x3D; 1; printf(&quot;%d %d&quot;, arr[i], i); &#125; &#125; &#x2F;&#x2F;若最终tag为0表示没有输出过，整个结果为0，输出0 0 if(!tag) &#123; printf(&quot;0 0&quot;); &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; int n1, n2, i, j, a, b; &#x2F;&#x2F;数组置0 memset(t1, 0, sizeof(t1)); memset(t2, 0, sizeof(t2)); memset(t3, 0, sizeof(t3)); memset(t4, 0, sizeof(t4)); scanf(&quot;%d&quot;, &amp;n1); for(i &#x3D; 0; i &lt; n1; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); t1[b] &#x3D; a; &#125; scanf(&quot;%d&quot;, &amp;n2); for(i &#x3D; 0; i &lt; n2; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); t2[b] &#x3D; a; &#125; &#x2F;&#x2F;计算乘法 for(i &#x3D; 0; i &lt;&#x3D; max; ++i) &#123; for(j &#x3D; 0; j &lt;&#x3D; max; ++j) &#123; t3[i + j] +&#x3D; t1[i] * t2[j]; &#125; &#125; &#x2F;&#x2F;计算加法 for(i &#x3D; 0; i &lt;&#x3D; max; ++i) &#123; t4[i] &#x3D; t1[i] + t2[i]; &#125; &#x2F;&#x2F;输出 show(t3, max * 2); show(t4, max); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PTA两个有序链表序列的合并","slug":"PTA两个有序链表序列的合并","date":"2020-08-12T15:51:42.151Z","updated":"2020-08-12T15:57:09.694Z","comments":true,"path":"2020/08/12/PTA两个有序链表序列的合并/","link":"","permalink":"http://yoursite.com/2020/08/12/PTA%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6/","excerpt":"考察链表基本操作，C语言解法","text":"考察链表基本操作，C语言解法 本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。 函数接口定义1List Merge( List L1, List L2 ); 其中 List 结构定义如下 123456typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; &#x2F;* 存储结点数据 *&#x2F; PtrToNode Next; &#x2F;* 指向下一个结点的指针 *&#x2F;&#125;;typedef PtrToNode List; &#x2F;* 定义单链表类型 *&#x2F; L1 和 L2 是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数 Merge 要将 L1 和 L2 合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。 裁判测试程序样例1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode List;List Read(); &#x2F;* 细节在此不表 *&#x2F;void Print( List L ); &#x2F;* 细节在此不表；空链表将输出NULL *&#x2F;List Merge( List L1, List L2 );int main()&#123; List L1, L2, L; L1 &#x3D; Read(); L2 &#x3D; Read(); L &#x3D; Merge(L1, L2); Print(L); Print(L1); Print(L2); return 0;&#125;&#x2F;* 你的代码将被嵌在这里 *&#x2F; C语言解法pa遍历L1, pb遍历L2, pc作为桥梁构建合链L 12345678910111213141516171819202122List Merge( List L1, List L2 ) &#123; List pa, pb, pc, L; L &#x3D; (List)malloc(sizeof(struct Node)); pa &#x3D; L1-&gt;Next; pb &#x3D; L2-&gt;Next; pc &#x3D; L; while(pa &amp;&amp; pb) &#123; if (pa-&gt;Data &lt;&#x3D; pb-&gt;Data) &#123; pc-&gt;Next &#x3D; pa; pc &#x3D; pa; pa &#x3D; pa-&gt;Next; &#125; else &#123; pc-&gt;Next &#x3D; pb; pc &#x3D; pb; pb &#x3D; pb-&gt;Next; &#125; &#125; pc-&gt;Next &#x3D; pa ? pa : pb; L1-&gt;Next &#x3D; NULL; L2-&gt;Next &#x3D; NULL; return L;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PTA二分查找法","slug":"PTA二分查找法","date":"2020-08-12T15:40:47.921Z","updated":"2020-08-12T16:21:16.063Z","comments":true,"path":"2020/08/12/PTA二分查找法/","link":"","permalink":"http://yoursite.com/2020/08/12/PTA%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/","excerpt":"挺早学但好像挺重要的，姑且记录一下，还是C语言解法","text":"挺早学但好像挺重要的，姑且记录一下，还是C语言解法 本题要求实现二分查找算法。 函数接口定义1Position BinarySearch( List L, ElementType X ); 其中 List 结构定义如下 123456typedef int Position;typedef struct LNode *List;struct LNode &#123; ElementType Data[MAXSIZE]; Position Last; &#x2F;* 保存线性表中最后一个元素的位置 *&#x2F;&#125;; L 是用户传入的一个线性表，其中 ElementType 元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数 BinarySearch 要查找 X 在 Data 中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记 NotFound 裁判测试程序样例1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10#define NotFound 0typedef int ElementType;typedef int Position;typedef struct LNode *List;struct LNode &#123; ElementType Data[MAXSIZE]; Position Last; &#x2F;* 保存线性表中最后一个元素的位置 *&#x2F;&#125;;List ReadInput(); &#x2F;* 裁判实现，细节不表。元素从下标1开始存储 *&#x2F;Position BinarySearch( List L, ElementType X );int main()&#123; List L; ElementType X; Position P; L &#x3D; ReadInput(); scanf(&quot;%d&quot;, &amp;X); P &#x3D; BinarySearch( L, X ); printf(&quot;%d\\n&quot;, P); return 0;&#125;&#x2F;* 你的代码将被嵌在这里 *&#x2F; C语言解法注意一下数据格式就行 1234567891011121314151617Position BinarySearch( List L, ElementType X ) &#123; int low, high, mid; low &#x3D; 0; high &#x3D; L-&gt;Last; while (low &lt;&#x3D; high) &#123; mid &#x3D; (low + high) &#x2F; 2; if(X &#x3D;&#x3D; L-&gt;Data[mid]) &#123; return mid; &#125; else if(X &lt; L-&gt;Data[mid]) &#123; high &#x3D; mid - 1; &#125;else&#123; low &#x3D; mid + 1; &#125; &#125; return NotFound;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"MaximumSubsequenceSum解法","slug":"MaximumSubsequenceSum解法","date":"2020-08-12T15:34:43.286Z","updated":"2020-08-12T15:39:25.365Z","comments":true,"path":"2020/08/12/MaximumSubsequenceSum解法/","link":"","permalink":"http://yoursite.com/2020/08/12/MaximumSubsequenceSum%E8%A7%A3%E6%B3%95/","excerpt":"最大子列和问题的变种，无非就是多加了找出最大子列和的第一个元素和最后一个元素","text":"最大子列和问题的变种，无非就是多加了找出最大子列和的第一个元素和最后一个元素 特点是在MaxSum更新的时候通过LastTag存入目前加上的数组元素的下标，从而找到最大子列和最后一个元素的下标，再倒推过来找到最大子列和的第一个元素的下标，存入FirstTag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int N, sum, FirstTag, LastTag, ThisSum, MaxSum, j, flag; flag &#x3D; 0; printf(&quot;请输入数字个数：&quot;); scanf(&quot;%d&quot;, &amp;N); int* A &#x3D; (int*)malloc(sizeof(int)*N); printf(&quot;请输入%d个数字：&quot;, N); for(int i &#x3D; 0; i &lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;A[i]); &#125; getchar(); ThisSum &#x3D; MaxSum &#x3D; 0; for (j &#x3D; 0;j &lt; N;j++) &#123; ThisSum +&#x3D; A[j]; if (ThisSum &gt; MaxSum) &#123; MaxSum &#x3D; ThisSum; LastTag &#x3D; j; &#125; else if (ThisSum &lt; 0) ThisSum &#x3D; 0; if(A[j] &gt;&#x3D; 0) &#123; flag &#x3D; 1; &#125; &#125; sum &#x3D; 0; for(int l &#x3D; LastTag; l &gt;&#x3D; 0; l--) &#123; sum +&#x3D; A[l]; if(sum &#x3D;&#x3D; MaxSum) &#123; FirstTag &#x3D; l; &#125; &#125; if(MaxSum) &#123; printf(&quot;最大子序列和为%d\\n&quot;, MaxSum); &#125; else if(flag) &#123; printf(&quot;最大子序列和为0\\n&quot;); &#125; printf(&quot;最大子列和第一个元素为%d, 最后一个元素为%d\\n&quot;, A[FirstTag], A[LastTag]); getchar(); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PTA最大子列和问题","slug":"PTA最大子列和问题","date":"2020-08-12T15:14:14.246Z","updated":"2020-08-12T16:01:41.220Z","comments":true,"path":"2020/08/12/PTA最大子列和问题/","link":"","permalink":"http://yoursite.com/2020/08/12/PTA%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/","excerpt":"采用C语言解法，后续可能会补充其他语种的写法","text":"采用C语言解法，后续可能会补充其他语种的写法 题目给定K个整数组成的序列{ N1, N2, …, NK }，“连续子列”被定义为{ Ni, Ni+1, …, Nj }，其中 1 ≤ i ≤ j ≤ K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下： 数据1：与样例等价，测试基本正确性; 数据2：102个随机整数; 数据3：103个随机整数; 数据4：104个随机整数; 数据5：105个随机整数; 输入格式输入第1行给出正整数K ( ≤100000 )；第2行给出K个整数，其间以空格分隔。 输出格式在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 输入样例126-2 11 -4 13 -5 -2 输出样例120 C语言解法遍历整个数组时，ThisSum作为遍历数组的和，MaxSum不断靠ThisSum更新和大小，ThisSum &lt; 0时ThisSum会清零 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#define MAXN 100000 &#x2F;&#x2F;本题最大数据是十万int MaxSubSequenceSum(const int A[], int N)&#123; int ThisSum, MaxSum, j; ThisSum &#x3D; MaxSum &#x3D; 0; for (j &#x3D; 0;j &lt; N;j++) &#123; ThisSum +&#x3D; A[j]; if (ThisSum &gt; MaxSum) MaxSum &#x3D; ThisSum; else if (ThisSum &lt; 0) ThisSum &#x3D; 0; &#125; return MaxSum;&#125;int main(void) &#123; int K, i; scanf(&quot;%d&quot;, &amp;K); int* a &#x3D; (int*)malloc(sizeof(int)*K); for ( i &#x3D; 0; i &lt; K; i++ ) scanf(&quot;%d&quot;, &amp;a[i]); printf(&quot;%d&quot;, MaxSubSequenceSum( a, K )); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"日语格助词全解","slug":"日语格助词全解","date":"2020-08-12T05:49:18.558Z","updated":"2020-08-12T06:06:19.113Z","comments":true,"path":"2020/08/12/日语格助词全解/","link":"","permalink":"http://yoursite.com/2020/08/12/%E6%97%A5%E8%AF%AD%E6%A0%BC%E5%8A%A9%E8%AF%8D%E5%85%A8%E8%A7%A3/","excerpt":"整理一下日语的所有格助词用法，例如常用的が、を、に 仅供参考，怎么理解还得靠自己","text":"整理一下日语的所有格助词用法，例如常用的が、を、に 仅供参考，怎么理解还得靠自己 什么是格助词？表达单词和动词直接的逻辑关系 日文所有格助词：が を に へ と で から より まで が 表示动作或状态的主题（主词） 例：雨が 降ります りんごが 美味しいで 表示能力或者好恶的「对象」 例：お金が 欲しいです テレビが 買いたいです ドイツ語が できます 加在名词后面成为新名词 例：我が国 を 表示动作的对象 例：水を 飲みます 映画を 見ます 表示移动空间 例：階段を 上がります 公園を 散歩します -&gt; 公園で（で表示动作的场所） 表示某段时间 例：楽しい 時間を 過ごしました 表示离开的场所 例：電車を おります 表示一种感动或者特别提出某一点来讲 例：お忙しところを、どうもすみません に 表示存在的场所 例：つくえをの 上に ノートが あります 表示动作的时间或顺序 例：十時に いきます 一週間に 三回 デートを します（某段时间内的动作频率） 表示拥有者 例：私には 子供が 二人 います 表示动作主 例：私には できません 部下に これを やらせます（使役） 先生に 叱られました（被动） 表示归属附着点 例：電車に 乗ります 壁に ポスターを 貼ります 表示变化结果 例：水が 氷に おりました ～に なります＝～で ございます 紅茶に おります（您点的红茶） 东西的接受者/受惠者（间接对象） 例：子供に おやつを あげます 恋人に 記念品を 買います 表示动作的对象（没有触及对方的抽象动作） 例：お客さんに 会います 先生に 聞きます 母に 何を もらいます 对象抽象 例：あなたの 意見に 賛成します 天文学に 詳しいですね 表示目的 例：新宿へ 買い物に 行きます 原因 例：勉強に 疲れました（心理） -&gt; 勉強で 疲れました（生理） 附加 例：黒のスーツに 黒のネクタイの 男が いる 表示动作的重复 例：走りに 走って やっと 間に合いました へ 动作方向 例：自宅へ 向かいます 部屋へ 戻ります 彼女への プレゼントを 買います と 表示并列 例：教室に 山田さんと 林さんが います 表示一起做某动作的对方 例：花子と 結婚しました 表示对称关系 例：以前と 違います 表示对话或思考的内容 例：安井さんも 行くと 言いましたよ 表示变化的结果 例：雪が 雨と ありました 塵も 積もれば 山と なります 表示加强一种状态 例：うわさは 人から 人へと 伝わるものです あの選手は 小柄ながら 三位と 健闘しました ずっと きっと たっと 二度と で 表示动作的场所 例：教室で 勉強します 教室の中で 弁当を 食べました 表示工具、方法、手段 例：自転車で 行きます 鉛筆で 書きます 表示原因 例：風邪で 会社を 休みました 寒さで 震えます 表示材料 例：紙で 飛行機を 作ります 試験の結果で 判断します 表范围、限度 例：15人で 締め切ります 一週間で 習得します 表示状态 例：今年で 二十歳に なります 大声で 叫びます 表动作者 例：みんあで 協力して 大会を 成功させましぃう 表示最低限度或方法 例：あなたの そばに いるだけで、幸せです から（从……去……） 表示动作或时间的起点 例：学校は 明日から 始まります 大学から でました（从大学走出来） -&gt; 大学を 出ました（从大学毕业） 表动作者 例：そのことは 私から 先生に 伝えますね 表示经过点 例：窓から 入りました 表示原因/理由/判断依据 例：別の立場から 考えます 表示原料（看不出原料的原样）-&gt; で（看得出原料） 例：酒は米から作られます 表示被动式里边的动作者 例：あの先生は みんなから 尊敬されています このことは 同級生から 教えられました まで 表示动作或者事情结束的时间跟地点 例：福岡まで 飛行機で いきました 仕事が 終わるまで 待ちましょう 用「～から ～まで」的句型表示明确的范围 例：仕事は 九時から 五時までです 不明确范围用「～から ～に かけて」 例：東京から 名古屋に かけて 大雨の 恐れが あります 表最低限度，「连……都……」 例：雪まで降ってきた あなたが 泣きと、私もで 悲しく なります より 比较/选择的对象 例：アメリカは 日本より 大きいです 花より 団子 表示地点或者时间的起点 例：四時より 会議を 始めます 遠方より 昔の友達が やってきました 表示一种限定（除了……别的方法） 例：待つより 仕方が ありません","categories":[{"name":"日语","slug":"日语","permalink":"http://yoursite.com/categories/%E6%97%A5%E8%AF%AD/"}],"tags":[{"name":"日语","slug":"日语","permalink":"http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"}]},{"title":"日语动词变形方法全解","slug":"日语动词变形","date":"2020-08-12T03:59:21.241Z","updated":"2020-08-12T04:14:27.009Z","comments":true,"path":"2020/08/12/日语动词变形/","link":"","permalink":"http://yoursite.com/2020/08/12/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/","excerpt":"在学习日语的过程中动词变形还是比较难的一道坎，在此做一个整理。","text":"在学习日语的过程中动词变形还是比较难的一道坎，在此做一个整理。 1、动词ます形变化规则五段动词：将结尾假名变成它同行的前一个假名后+ます 例：行く～行きます 買う～買います 一段动词：去る＋ます 例：食べる～食べます 起きる～起きます カ变动词：来（く）る～来（き）ます サ变动词：する～します 例：勉強する～勉強します 特殊五段动词：帰る～帰ります 知る～知ります 入る～入ります 要る～要ります 切る～切ります 走る～走ります 等2、动词ない形 五段动词：将结尾假名变成它同行的あ段上的假名后+ない。 例：行く→行かない 買う→買わない 一段动词：去る+ない 例：食べる→食べない 起きる→起きない カ变动词：来る→来（こ）ない サ变动词：する→しない 例：勉強する→勉強しない 特殊五段动词：帰る→帰らない 知る→知らない 其它的以此类推，将る变成ら+ない 3、动词可能形五段动词：将结尾假名变成它同行的下一个假名后+る。 例：行く→行ける 買う→買える 一段动词：去る+られる。 例：食べる→食べられる 起きる→起きられる カ变动词：来る→来（こ）られる サ变动词：する→できる 例：勉強する→勉強できる 4、动词て形五段动词： く→いて ぐ→いで 例：書く→書いて 脱ぐ→脱いで う、つ、る为结尾的，去掉う、つ、る＋って 例：買う→買って 立つ→立って 終わる→終わって む、ぬ、ぶ为结尾的去掉+む、ぬ、ぶ＋んで 例：飲む→飲んで 死ぬ→死んで 飛ぶ→飛んで 以す为结尾的す→して 例：話す→話して 一段动词：去る+て 例：食べる→食べて 起きる→起きて カ变动词：来る→来（き）て サ变动词：する→して 例：勉強する→勉強して 例外：行く→行って 帰る→帰って 知る→知って 5、假定形五段动词：将结尾假名变成它同行的下一个假名后+ば 例：行く→行けば 買う→買えば 一段动词：去る+れば 例：食べる→食べれば 起きる→起きれば カ变动词： 来る→来（く）れば サ变动词： する→すれば 例：散歩する→散歩すれば 形容词：去い+ければ 例：安い→安ければ おいしい→おいしければ 形容动词：去だ+なら 例：暇だ→暇なら 簡単だ→簡単なら 名词：名词直接+なら 例：日本人→日本人なら 6、动词意向形五段动词：将结尾假名变成它同行的最后一个假名后+う 例：行く→行こう 買う→買おう 一段动词：去る+よう 例：食べる→食べよう 起きる→起きよう カ变动词： 来る→来（こ）よう サ变动词： する→しよう 例：散歩する→散歩しよう 7、动词命令形五段动词：将结尾假名变成它同行的下一个假名即可. 例：行く→行け 買う→買え 一段动词：去る+ろ 例：起きる→起きろ 食べる→食べろ カ变动词： 来る→来（こ）い サ变动词： する→しろ/せよ 例：勉強する→勉強しろ/せよ 动词禁止形是所有词的字典形（原形、基本形）+な 例：行く→行くな 起きる→起きるな 来る→来（く）るな 勉強する→勉強するな 8、动词被动形五段动词：将结尾假名变成它所在行的あ段上假名后+れる 例：踏む→踏まれる 呼ぶ→呼ばれる 一段动词：去る+られる 例：褒める→褒められる 食べる→食べられる カ变动词： 来る→来（こ）られる サ变动词： する→される 例：発明する→発明される 9、动词使役形五段动词：将结尾假名变成它所在行的あ段上假名后+せる。 例：行く→行かせる 飲む→飲ませる 一段动词：去る+させる 例：食べる→食べさせる 起きる→起きさせる カ变动词： 来る→来（こ）させる サ变动词： する→させる 例：勉強する→勉強させる 沪江日语原文","categories":[{"name":"日语","slug":"日语","permalink":"http://yoursite.com/categories/%E6%97%A5%E8%AF%AD/"}],"tags":[{"name":"日语","slug":"日语","permalink":"http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"}]},{"title":"Hello World!","slug":"hello-world","date":"2020-08-09T12:33:32.266Z","updated":"2020-08-11T07:10:15.243Z","comments":true,"path":"2020/08/09/hello-world/","link":"","permalink":"http://yoursite.com/2020/08/09/hello-world/","excerpt":"A New Start","text":"A New Start 和其他大佬不一样，我是第一次搭建个人博客 多亏大佬们的博文，基于Github Page和hexo搭建的博客上手起来不难，不过还有很多细节需要慢慢添加调整，估计建起一个美观与实用兼顾的博客需要耗费不少精力 - -||| 回到博客这边，为什么要写博客，有以下好处： 觉得懂未必懂，写作是一个很好的反思过程 好记性不如烂笔头，容易遗忘的知识点通过浏览写过的博客能快速重新掌握 结交志同道合的朋友，大佬之间经常通过博客作为交流渠道，不过目前这不是重点 博客的内容大部分会记录我学过的一些知识、错题和遇到的种种BUG，如果学到了大体系的知识也会考虑记录进博客做整理 博客配置，主题采用volantis，使用github进行版本控制，后边可能会考虑用上coding 这是一次全新的开始，祝： 一路开心！","categories":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"},{"name":"日语","slug":"日语","permalink":"http://yoursite.com/categories/%E6%97%A5%E8%AF%AD/"},{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"日语","slug":"日语","permalink":"http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}