{"meta":{"title":"Typhoonix's Blog","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-08-10T08:36:14.799Z","updated":"2020-08-10T08:36:14.799Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2020-08-12T01:41:28.211Z","updated":"2020-08-12T01:41:28.211Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"广东工业大学，电子科学与技术本科在读 目前主要学习 Web前后端/硬件/日语/etc… 有开发游戏的小想法 核乐狗，主要偏向前卫金 不知何时能重操旧业的混音人"},{"title":"所有分类","date":"2020-08-11T07:56:45.199Z","updated":"2020-08-11T07:56:45.199Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-08-11T07:57:00.177Z","updated":"2020-08-11T07:57:00.177Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-08-12T17:12:18.341Z","updated":"2020-08-12T17:12:18.341Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"下边是我的朋友或者一些大佬的博客链接","text":"下边是我的朋友或者一些大佬的博客链接"},{"title":"","date":"2020-08-10T08:35:32.071Z","updated":"2020-08-10T08:35:32.071Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"List,Set,Map详解与区别","slug":"List,Set,Map详解与区别","date":"2020-10-24T03:14:15.647Z","updated":"2020-10-24T03:33:13.041Z","comments":true,"path":"2020/10/24/List,Set,Map详解与区别/","link":"","permalink":"http://yoursite.com/2020/10/24/List,Set,Map%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%8C%BA%E5%88%AB/","excerpt":"三种数据类型在不同场合有不同的需求，特此记录","text":"三种数据类型在不同场合有不同的需求，特此记录 一、List接口List是一个继承于Collection的接口，即List是集合中的一种。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和Set不同，List中允许有重复的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 ArrayListArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量： private static final int DEFAULT_CAPACITY = 10; 随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。 size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。 ArrayList擅长于随机访问。同时ArrayList是非同步的。 LinkedList同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。 由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端，节约一半时间）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。 与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(…)); Vector与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。 StackStack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 二、Set接口Set是一个继承于Collection的接口，Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，关于API方面。Set的API和Collection完全一样。实现了Set接口的集合有：HashSet、TreeSet、LinkedHashSet、EnumSet。 HashSetHashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。集合元素可以是null,但只能放入一个null。它内部元素的顺序是由哈希码来决定的，所以它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。 TreeSetTreeSet是二叉树实现的，基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现，不允许放入null值。它是使用元素的自然顺序对元素进行排序，或者根据创建Set时提供的 Comparator 进行排序，具体取决于使用的构造方法。 LinkedHashSetLinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。 三、Map接口Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的集合有：HashMap、HashTable、TreeMap、WeakHashMap。 HashMap以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 HashTable也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式。HashTable继承Dictionary类，实现Map接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类。每个键和每个值都是一个对象。在任何一个 Dictionary 对象中，每个键至多与一个值相关联。Map是”key-value键值对”接口。 HashTable采用”拉链法”实现哈希表不过性能比HashMap要低。 TreeMap有序散列表，实现SortedMap接口，底层通过红黑树实现。 WeakHashMap谈WeakHashMap前先看一下Java中的引用（强度依次递减） 强引用：普遍对象声明的引用，存在便不会GC软引用：有用但并非必须，发生内存溢出前，二次回收弱引用：只能生存到下次GC之前，无论是否内存足够虚引用：唯一目的是在这个对象被GC时能收到一个系统通知以弱键实现的基于哈希表的Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的 Map 实现有所不同。null值和null键都被支持。该类具有与HashMap类相似的性能特征,并具有相同的效能参数初始容量和加载因子。像大多数集合类一样，该类是不同步的。 四、总结 List、Set都是继承自Collection接口，Map则不是 List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。） Set和List对比： Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。 List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。 Map适合储存键值对的数据 线程安全集合类与非线程安全集合类 : LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;HashMap是非线程安全的，HashTable是线程安全的;StringBuilder是非线程安全的，StringBuffer是线程安全的。 参考链接： Java容器类总结 Java中List，Set和Map详解及其区别和使用场景","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"java","slug":"后端/java","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Tomcat的HTTP请求","slug":"Tomcat的HTTP请求","date":"2020-10-13T14:49:22.671Z","updated":"2020-10-17T03:19:34.535Z","comments":true,"path":"2020/10/13/Tomcat的HTTP请求/","link":"","permalink":"http://yoursite.com/2020/10/13/Tomcat%E7%9A%84HTTP%E8%AF%B7%E6%B1%82/","excerpt":"Tomcat的实际运作原理，特此记录。","text":"Tomcat的实际运作原理，特此记录。 Tomcat的http请求方式如下 用户点击网页内容，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得。 Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应。 Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host。 Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有的Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）。 path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL PATTERN为*.jsp的Servlet,对应于JspServlet类。 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet（）或doPost（）.执行业务逻辑、数据存储等程序。 Context把执行完之后的HttpServletResponse对象返回给Host。 Host把HttpServletResponse对象返回给Engine。 Engine把HttpServletResponse对象返回Connector。 Connector把HttpServletResponse对象返回给客户Browser。 参考博文：Tomcat简介","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Web Server","slug":"后端/Web-Server","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/Web-Server/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Web Server","slug":"Web-Server","permalink":"http://yoursite.com/tags/Web-Server/"}]},{"title":"Java单例模式详解","slug":"单例模式","date":"2020-10-13T13:24:34.121Z","updated":"2020-10-13T14:05:55.485Z","comments":true,"path":"2020/10/13/单例模式/","link":"","permalink":"http://yoursite.com/2020/10/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"关于java单例模式的详解，面试貌似会经常碰到，而且里边也藏着很深的知识点，特此记录一下","text":"关于java单例模式的详解，面试貌似会经常碰到，而且里边也藏着很深的知识点，特此记录一下 首先是简单的实现方法 懒汉式： 1234567891011public class Singleton &#123; private Singleton() &#123;&#125; &#x2F;&#x2F;私有构造函数 private static Singleton instance &#x3D; null; &#x2F;&#x2F;单例对象 &#x2F;&#x2F;静态工厂方法 public static Singleton getInstance() &#123; if (instance &#x3D;&#x3D; null) &#123; instance &#x3D; new Singleton(); &#125; return instance; &#125;&#125; 饿汉式： 123456789101112public class Singleton &#123; private static Singleton instance &#x3D; new Singleton(); &#x2F;&#x2F; 私有化构造方法 private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 为什么这样写呢？我们来解释几个关键点： 1.要想让一个类只能构建一个对象，自然不能让它随便去做new操作，因此Signleton的构造方法是私有的。 2.instance是Singleton类的静态成员，也是我们的单例对象。它的初始值可以写成Null，也可以写成new Singleton()。至于其中的区别后来会做解释。 3.getInstance是获取单例对象的方法。 如果单例初始值是null，还未构建，则构建单例对象并返回。这个写法属于单例模式当中的懒汉模式。 如果单例对象一开始就被new Singleton()主动构建，则不再需要判空操作，这种写法属于饿汉模式。 这两个名字很形象：饿汉主动找食物吃，懒汉躺在地上等着人喂。 但此写法的线程并不安全 why？ 假设Singleton类刚刚被初始化，instance对象还是空，这时候两个线程同时访问getInstance方法： 因为Instance是空，所以两个线程同时通过了条件判断，开始执行new操作： 这样一来，显然instance被构建了两次。让我们对代码做一下修改： 123456789101112131415public class Singleton &#123; private Singleton() &#123;&#125; &#x2F;&#x2F;私有构造函数 private static Singleton instance &#x3D; null; &#x2F;&#x2F;单例对象 &#x2F;&#x2F;静态工厂方法 public static Singleton getInstance() &#123; if (instance &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;双重检测机制 synchronized (Singleton.class)&#123; &#x2F;&#x2F;同步锁 if (instance &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;双重检测机制 instance &#x3D; new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 为什么这样写呢？我们来解释几个关键点： 1.为了防止new Singleton被执行多次，因此在new操作之前加上Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）。 2.进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。 像这样两次判空的机制叫做双重检测机制。 可是这并非是绝对线程安全的 why? 这里涉及到了JVM编译器的指令重排。 指令重排是什么意思呢？比如java中简单的一句 instance = new Singleton，会被编译器编译成如下JVM指令： 12345memory &#x3D;allocate(); &#x2F;&#x2F;1：分配对象的内存空间ctorInstance(memory); &#x2F;&#x2F;2：初始化对象instance &#x3D;memory; &#x2F;&#x2F;3：设置instance指向刚分配的内存地址 但是这些指令顺序并非一成不变，有可能会经过JVM和CPU的优化，指令重排成下面的顺序： 12345memory &#x3D;allocate(); &#x2F;&#x2F;1：分配对象的内存空间instance &#x3D;memory; &#x2F;&#x2F;3：设置instance指向刚分配的内存地址ctorInstance(memory); &#x2F;&#x2F;2：初始化对象 当线程A执行完1,3,时，instance对象还未完成初始化，但已经不再指向null。此时如果线程B抢占到CPU资源，执行 if（instance == null）的结果会是false，从而返回一个没有初始化完成的instance对象。如下图所示： 如何避免这一情况呢？我们需要在instance对象前面增加一个修饰符volatile。 123456789101112131415public class Singleton &#123; private Singleton() &#123;&#125; &#x2F;&#x2F;私有构造函数 private volatile static Singleton instance &#x3D; null; &#x2F;&#x2F;单例对象 &#x2F;&#x2F;静态工厂方法 public static Singleton getInstance() &#123; if (instance &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;双重检测机制 synchronized (Singleton.class)&#123; &#x2F;&#x2F;同步锁 if (instance &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;双重检测机制 instance &#x3D; new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; volatile修饰符阻止了变量访问前后的指令重排，保证了指令执行顺序。 经过volatile的修饰，当线程A执行instance = new Singleton的时候，JVM执行顺序是什么样？始终保证是下面的顺序： 12345memory &#x3D;allocate(); &#x2F;&#x2F;1：分配对象的内存空间ctorInstance(memory); &#x2F;&#x2F;2：初始化对象instance &#x3D;memory; &#x2F;&#x2F;3：设置instance指向刚分配的内存地址 如此在线程B看来，instance对象的引用要么指向null，要么指向一个初始化完毕的Instance，而不会出现某个中间态，保证了安全。 还有其他实现单例模式的方法： 用静态内部类实现单例模式： 123456789public class Singleton &#123; private static class LazyHolder &#123; private static final Singleton INSTANCE &#x3D; new Singleton(); &#125; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; 这里有几个需要注意的点： 1.从外部无法访问静态内部类LazyHolder，只有当调用Singleton.getInstance方法的时候，才能得到单例对象INSTANCE。 2.INSTANCE对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。因此这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。 利用反射打破单例模式的约束，代码如下： 123456789&#x2F;&#x2F;获得构造器Constructor con &#x3D; Singleton.class.getDeclaredConstructor();&#x2F;&#x2F;设置为可访问con.setAccessible(true);&#x2F;&#x2F;构造两个不同的对象Singleton singleton1 &#x3D; (Singleton)con.newInstance();Singleton singleton2 &#x3D; (Singleton)con.newInstance();&#x2F;&#x2F;验证是否是不同对象System.out.println(singleton1.equals(singleton2)); 代码可以简单归纳为三个步骤： 第一步，获得单例类的构造器。 第二步，把构造器设置为可访问。 第三步，使用newInstance方法构造对象。 最后为了确认这两个对象是否真的是不同的对象，我们使用equals方法进行比较。毫无疑问，比较结果是false。 可以用枚举法实现单例模式，防止反射，也能保证线程安全： 123public enum SingletonEnum &#123; INSTANCE;&#125; 在使用枚举法的情况下仍然执行刚刚的反射代码： 123456789&#x2F;&#x2F;获得构造器Constructor con &#x3D; Singleton.class.getDeclaredConstructor();&#x2F;&#x2F;设置为可访问con.setAccessible(true);&#x2F;&#x2F;构造两个不同的对象Singleton singleton1 &#x3D; (Singleton)con.newInstance();Singleton singleton2 &#x3D; (Singleton)con.newInstance();&#x2F;&#x2F;验证是否是不同对象System.out.println(singleton1.equals(singleton2)); 执行获得构造器这一步的时候，抛出了如下异常： Exception in thread “main” java.lang.NoSuchMethodException: com.xiaohui.singleton.test.SingletonEnum.() at java.lang.Class.getConstructor0(Class.java:2892) at java.lang.Class.getDeclaredConstructor(Class.java:2058) at com.xiaohui.singleton.test.SingletonTest.main(SingletonTest.java:22) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134) 枚举法缺点：并非使用懒加载，其单例模式是在枚举类被加载的时候进行初始化的。 总结： 几点补充： volatile关键字不但可以防止指令重排，也可以保证线程访问的变量值是主内存中的最新值。有关volatile的详细原理，我在以后的漫画中会专门讲解。 使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现readResolve方法。 参考博文： 漫画：什么是单例模式 java 单例模式的几种实现方式","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"java","slug":"后端/java","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"PTA排序算法","slug":"PTA排序算法","date":"2020-08-21T16:12:29.834Z","updated":"2020-08-21T16:43:43.367Z","comments":true,"path":"2020/08/22/PTA排序算法/","link":"","permalink":"http://yoursite.com/2020/08/22/PTA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"整理一下各种排序算法的C语言写法以及运行结果，对排序有个清晰认知","text":"整理一下各种排序算法的C语言写法以及运行结果，对排序有个清晰认知 题目给定N个（长整型范围内的）整数，要求输出从小到大排序后的结果。 本题旨在测试各种不同的排序算法在各种数据情况下的表现。各组测试数据特点如下： 数据1：只有1个元素； 数据2：11个不相同的整数，测试基本正确性； 数据3：103个随机整数； 数据4：104个随机整数； 数据5：105个随机整数； 数据6：105个顺序整数； 数据7：105个逆序整数； 数据8：105个基本有序的整数； 数据9：105个随机正整数，每个数字不超过1000。 输入格式输入第一行给出正整数N（ ≤105 ），随后一行给出N个（长整型范围内的）整数，其间以空格分隔。 输出格式在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。 输入样例12114 981 10 -17 0 -20 29 50 8 43 -5 输出样例1-20 -17 -5 0 4 8 10 29 43 50 981 解法 选择排序（大数据直接运行超时） 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;*PTA运行成功*&#x2F;void InsertionSort(int a[], int n)&#123; &#x2F;* 插入排序 *&#x2F; int P, i; int Tmp; for (P &#x3D; 1; P &lt; n; P++) &#123; Tmp &#x3D; a[P]; &#x2F;* 取出未排序序列中的第一个元素*&#x2F; for (i &#x3D; P; i &gt; 0 &amp;&amp; a[i - 1] &gt; Tmp; i--) a[i] &#x3D; a[i - 1]; &#x2F;*依次与已排序序列中元素比较并右移*&#x2F; a[i] &#x3D; Tmp; &#x2F;* 放进合适的位置 *&#x2F; &#125; for (i &#x3D; 0; i &lt; n; i++) &#123; printf(&quot;%d%c&quot;, a[i], i &lt; n - 1 ? &#39; &#39; : &#39;\\n&#39;); &#125;&#125;int main() &#123; int n, i; scanf(&quot;%d&quot;, &amp;n); int* a &#x3D; (int*)malloc(sizeof(int)*n); for(i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; InsertionSort(a, n); return 0;&#125; 冒泡排序（部分大数据会超时） 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;*PTA数据5和数据9运行会超时*&#x2F;void Bubble_Sort(int a[], int n)&#123; int i, j, t; int flag; for (i &#x3D; 0; i &lt; n - 1; i++) &#123; flag &#x3D; 0; &#x2F;*加一个标识符方便快速排完序*&#x2F; for (j &#x3D; 0; j &lt; n - 1 - i; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; t &#x3D; a[j]; a[j] &#x3D; a[j + 1]; a[j + 1] &#x3D; t; flag &#x3D; 1; &#125; &#125; if (flag &#x3D;&#x3D; 0) &#123; break; &#125; &#125; for (i &#x3D; 0; i &lt; n; i++) &#123; printf(&quot;%d%c&quot;, a[i], i &lt; n - 1 ? &#39; &#39; : &#39;\\n&#39;); &#125;&#125;int main() &#123; int n, i; scanf(&quot;%d&quot;, &amp;n); int* a &#x3D; (int*)malloc(sizeof(int)*n); for(i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; Bubble_Sort(a, n); return 0;&#125; 插入排序 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;*PTA运行成功*&#x2F;void InsertionSort(int a[], int n)&#123; &#x2F;* 插入排序 *&#x2F; int P, i; int Tmp; for (P &#x3D; 1; P &lt; n; P++) &#123; Tmp &#x3D; a[P]; &#x2F;* 取出未排序序列中的第一个元素*&#x2F; for (i &#x3D; P; i &gt; 0 &amp;&amp; a[i - 1] &gt; Tmp; i--) a[i] &#x3D; a[i - 1]; &#x2F;*依次与已排序序列中元素比较并右移*&#x2F; a[i] &#x3D; Tmp; &#x2F;* 放进合适的位置 *&#x2F; &#125; for (i &#x3D; 0; i &lt; n; i++) &#123; printf(&quot;%d%c&quot;, a[i], i &lt; n - 1 ? &#39; &#39; : &#39;\\n&#39;); &#125;&#125;int main() &#123; int n, i; scanf(&quot;%d&quot;, &amp;n); int* a &#x3D; (int*)malloc(sizeof(int)*n); for(i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; InsertionSort(a, n); return 0;&#125; 希尔排序 Sedgewick增量序列以外还有其他序列可用 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;*PTA运行成功*&#x2F;void ShellSort(int A[], int N)&#123; &#x2F;* 希尔排序 - 用Sedgewick增量序列 *&#x2F; int Si, D, P, i; int Tmp; &#x2F;* 这里只列出一小部分增量 *&#x2F; int Sedgewick[] &#x3D; &#123;929, 505, 209, 109, 41, 19, 5, 1, 0&#125;; for (Si &#x3D; 0; Sedgewick[Si] &gt;&#x3D; N; Si++) ; &#x2F;* 初始的增量Sedgewick[Si]不能超过待排序列长度 *&#x2F; for (D &#x3D; Sedgewick[Si]; D &gt; 0; D &#x3D; Sedgewick[++Si]) for (P &#x3D; D; P &lt; N; P++) &#123; &#x2F;* 插入排序, 将1改成D即可*&#x2F; Tmp &#x3D; A[P]; for (i &#x3D; P; i &gt;&#x3D; D &amp;&amp; A[i - D] &gt; Tmp; i -&#x3D; D) A[i] &#x3D; A[i - D]; A[i] &#x3D; Tmp; &#125; for (i &#x3D; 0; i &lt; N; i++) &#123; printf(&quot;%d%c&quot;, A[i], i &lt; N - 1 ? &#39; &#39; : &#39;\\n&#39;); &#125;&#125;int main() &#123; int n, i; scanf(&quot;%d&quot;, &amp;n); int* a &#x3D; (int*)malloc(sizeof(int)*n); for(i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; ShellSort(a, n); return 0;&#125; 堆排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;*PTA运行成功*&#x2F;void Swap(int *a, int *b)&#123; int t &#x3D; *a; *a &#x3D; *b; *b &#x3D; t;&#125;void PercDown(int A[], int p, int N)&#123; &#x2F;* 改编代码4.24的PercDown( MaxHeap H, int p ) *&#x2F; &#x2F;* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 *&#x2F; int Parent, Child; int X; X &#x3D; A[p]; &#x2F;* 取出根结点存放的值 *&#x2F; for (Parent &#x3D; p; (Parent * 2 + 1) &lt; N; Parent &#x3D; Child) &#123; Child &#x3D; Parent * 2 + 1; if ((Child !&#x3D; N - 1) &amp;&amp; (A[Child] &lt; A[Child + 1])) Child++; &#x2F;* Child指向左右子结点的较大者 *&#x2F; if (X &gt;&#x3D; A[Child]) break; &#x2F;* 找到了合适位置 *&#x2F; else &#x2F;* 下滤X *&#x2F; A[Parent] &#x3D; A[Child]; &#125; A[Parent] &#x3D; X;&#125;void Heap_Sort(int A[], int N)&#123; &#x2F;* 堆排序 *&#x2F; int i; for (i &#x3D; N &#x2F; 2 - 1; i &gt;&#x3D; 0; i--) &#x2F;* 建立最大堆 *&#x2F; PercDown(A, i, N); for (i &#x3D; N - 1; i &gt; 0; i--) &#123; &#x2F;* 删除最大堆顶 *&#x2F; Swap(&amp;A[0], &amp;A[i]); &#x2F;* 见代码7.1 *&#x2F; PercDown(A, 0, i); &#125; for (i &#x3D; 0; i &lt; N; i++) &#123; printf(&quot;%d%c&quot;, A[i], i &lt; N - 1 ? &#39; &#39; : &#39;\\n&#39;); &#125;&#125;int main() &#123; int n, i; scanf(&quot;%d&quot;, &amp;n); int* a &#x3D; (int*)malloc(sizeof(int)*n); for(i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; Heap_Sort(a, n); return 0;&#125; 归并排序 递归法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;*PTA运行成功*&#x2F;&#x2F;* 归并排序 - 递归实现 *&#x2F;&#x2F;* L &#x3D; 左边起始位置, R &#x3D; 右边起始位置, RightEnd &#x3D; 右边终点位置*&#x2F;void Merge(int A[], int TmpA[], int L, int R, int RightEnd)&#123; &#x2F;* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 *&#x2F; int LeftEnd, NumElements, Tmp; int i; LeftEnd &#x3D; R - 1; &#x2F;* 左边终点位置 *&#x2F; Tmp &#x3D; L; &#x2F;* 有序序列的起始位置 *&#x2F; NumElements &#x3D; RightEnd - L + 1; while (L &lt;&#x3D; LeftEnd &amp;&amp; R &lt;&#x3D; RightEnd) &#123; if (A[L] &lt;&#x3D; A[R]) TmpA[Tmp++] &#x3D; A[L++]; &#x2F;* 将左边元素复制到TmpA *&#x2F; else TmpA[Tmp++] &#x3D; A[R++]; &#x2F;* 将右边元素复制到TmpA *&#x2F; &#125; while (L &lt;&#x3D; LeftEnd) TmpA[Tmp++] &#x3D; A[L++]; &#x2F;* 直接复制左边剩下的 *&#x2F; while (R &lt;&#x3D; RightEnd) TmpA[Tmp++] &#x3D; A[R++]; &#x2F;* 直接复制右边剩下的 *&#x2F; for (i &#x3D; 0; i &lt; NumElements; i++, RightEnd--) A[RightEnd] &#x3D; TmpA[RightEnd]; &#x2F;* 将有序的TmpA[]复制回A[] *&#x2F;&#125;void Msort(int A[], int TmpA[], int L, int RightEnd)&#123; &#x2F;* 核心递归排序函数 *&#x2F; int Center; if (L &lt; RightEnd) &#123; Center &#x3D; (L + RightEnd) &#x2F; 2; Msort(A, TmpA, L, Center); &#x2F;* 递归解决左边 *&#x2F; Msort(A, TmpA, Center + 1, RightEnd); &#x2F;* 递归解决右边 *&#x2F; Merge(A, TmpA, L, Center + 1, RightEnd); &#x2F;* 合并两段有序序列 *&#x2F; &#125;&#125;void Merge_Sort(int A[], int N)&#123; &#x2F;* 归并排序 *&#x2F; int *TmpA, i; TmpA &#x3D; (int *)malloc(N * sizeof(int)); if (TmpA !&#x3D; NULL) &#123; Msort(A, TmpA, 0, N - 1); free(TmpA); &#125; else printf(&quot;空间不足&quot;); for (i &#x3D; 0; i &lt; N; i++) &#123; printf(&quot;%d%c&quot;, A[i], i &lt; N - 1 ? &#39; &#39; : &#39;\\n&#39;); &#125;&#125;int main() &#123; int n, i; scanf(&quot;%d&quot;, &amp;n); int* a &#x3D; (int*)malloc(sizeof(int)*n); for(i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; Merge_Sort(a, n); return 0;&#125; 非递归 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;*PTA运行成功*&#x2F;void Merge(int A[], int TmpA[], int L, int R, int RightEnd)&#123; &#x2F;* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 *&#x2F; int LeftEnd, NumElements, Tmp; int i; LeftEnd &#x3D; R - 1; &#x2F;* 左边终点位置 *&#x2F; Tmp &#x3D; L; &#x2F;* 有序序列的起始位置 *&#x2F; NumElements &#x3D; RightEnd - L + 1; while (L &lt;&#x3D; LeftEnd &amp;&amp; R &lt;&#x3D; RightEnd) &#123; if (A[L] &lt;&#x3D; A[R]) TmpA[Tmp++] &#x3D; A[L++]; &#x2F;* 将左边元素复制到TmpA *&#x2F; else TmpA[Tmp++] &#x3D; A[R++]; &#x2F;* 将右边元素复制到TmpA *&#x2F; &#125; while (L &lt;&#x3D; LeftEnd) TmpA[Tmp++] &#x3D; A[L++]; &#x2F;* 直接复制左边剩下的 *&#x2F; while (R &lt;&#x3D; RightEnd) TmpA[Tmp++] &#x3D; A[R++]; &#x2F;* 直接复制右边剩下的 *&#x2F; for (i &#x3D; 0; i &lt; NumElements; i++, RightEnd--) A[RightEnd] &#x3D; TmpA[RightEnd]; &#x2F;* 将有序的TmpA[]复制回A[] *&#x2F;&#125;&#x2F;* 归并排序 - 循环实现 *&#x2F;&#x2F;* 这里Merge函数在递归版本中给出 *&#x2F;&#x2F;* length &#x3D; 当前有序子列的长度*&#x2F;void Merge_pass(int A[], int TmpA[], int N, int length)&#123; &#x2F;* 两两归并相邻有序子列 *&#x2F; int i, j; for (i &#x3D; 0; i &lt;&#x3D; N - 2 * length; i +&#x3D; 2 * length) Merge(A, TmpA, i, i + length, i + 2 * length - 1); if (i + length &lt; N) &#x2F;* 归并最后2个子列*&#x2F; Merge(A, TmpA, i, i + length, N - 1); else &#x2F;* 最后只剩1个子列*&#x2F; for (j &#x3D; i; j &lt; N; j++) TmpA[j] &#x3D; A[j];&#125;void Merge_Sort(int A[], int N)&#123; int length, i; int *TmpA; length &#x3D; 1; &#x2F;* 初始化子序列长度*&#x2F; TmpA &#x3D; malloc(N * sizeof(int)); if (TmpA !&#x3D; NULL) &#123; while (length &lt; N) &#123; Merge_pass(A, TmpA, N, length); length *&#x3D; 2; Merge_pass(TmpA, A, N, length); length *&#x3D; 2; &#125; free(TmpA); &#125; else printf(&quot;空间不足&quot;); for (i &#x3D; 0; i &lt; N; i++) &#123; printf(&quot;%d%c&quot;, A[i], i &lt; N - 1 ? &#39; &#39; : &#39;\\n&#39;); &#125;&#125;int main() &#123; int n, i; scanf(&quot;%d&quot;, &amp;n); int* a &#x3D; (int*)malloc(sizeof(int)*n); for(i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; Merge_Sort(a, n); return 0;&#125; 快速排序 对Cutoff的5种不同取值：50、100、200、300、400等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;* 快速排序 *&#x2F;void Swap(int *a, int *b)&#123; int t &#x3D; *a; *a &#x3D; *b; *b &#x3D; t;&#125;void InsertionSort(int a[], int n)&#123; &#x2F;* 插入排序 *&#x2F; int P, i; int Tmp; for (P &#x3D; 1; P &lt; n; P++) &#123; Tmp &#x3D; a[P]; &#x2F;* 取出未排序序列中的第一个元素*&#x2F; for (i &#x3D; P; i &gt; 0 &amp;&amp; a[i - 1] &gt; Tmp; i--) a[i] &#x3D; a[i - 1]; &#x2F;*依次与已排序序列中元素比较并右移*&#x2F; a[i] &#x3D; Tmp; &#x2F;* 放进合适的位置 *&#x2F; &#125;&#125;int Median3(int A[], int Left, int Right)&#123; int Center &#x3D; (Left + Right) &#x2F; 2; if (A[Left] &gt; A[Center]) Swap(&amp;A[Left], &amp;A[Center]); if (A[Left] &gt; A[Right]) Swap(&amp;A[Left], &amp;A[Right]); if (A[Center] &gt; A[Right]) Swap(&amp;A[Center], &amp;A[Right]); &#x2F;* 此时A[Left] &lt;&#x3D; A[Center] &lt;&#x3D; A[Right] *&#x2F; Swap(&amp;A[Center], &amp;A[Right - 1]); &#x2F;* 将基准Pivot藏到右边*&#x2F; &#x2F;* 只需要考虑A[Left+1] … A[Right-2] *&#x2F; return A[Right - 1]; &#x2F;* 返回基准Pivot *&#x2F;&#125;void Qsort(int A[], int Left, int Right)&#123; &#x2F;* 核心递归函数 *&#x2F; int Pivot, Cutoff, Low, High; Cutoff &#x3D; 50; &#x2F;*对Cutoff的5种不同取值：50、100、200、300、400等*&#x2F; if (Cutoff &lt;&#x3D; Right - Left) &#123; &#x2F;* 如果序列元素充分多，进入快排 *&#x2F; Pivot &#x3D; Median3(A, Left, Right); &#x2F;* 选基准 *&#x2F; Low &#x3D; Left; High &#x3D; Right - 1; while (1) &#123; &#x2F;*将序列中比基准小的移到基准左边，大的移到右边*&#x2F; while (A[++Low] &lt; Pivot) ; while (A[--High] &gt; Pivot) ; if (Low &lt; High) Swap(&amp;A[Low], &amp;A[High]); else break; &#125; Swap(&amp;A[Low], &amp;A[Right - 1]); &#x2F;* 将基准换到正确的位置 *&#x2F; Qsort(A, Left, Low - 1); &#x2F;* 递归解决左边 *&#x2F; Qsort(A, Low + 1, Right); &#x2F;* 递归解决右边 *&#x2F; &#125; else InsertionSort(A + Left, Right - Left + 1); &#x2F;* 元素太少，用简单排序 *&#x2F;&#125;void QuickSort(int A[], int N)&#123; &#x2F;* 统一接口 *&#x2F; int i; Qsort(A, 0, N - 1); for (i &#x3D; 0; i &lt; N; i++) &#123; printf(&quot;%d%c&quot;, A[i], i &lt; N - 1 ? &#39; &#39; : &#39;\\n&#39;); &#125;&#125;int main()&#123; int n, i; scanf(&quot;%d&quot;, &amp;n); int *a &#x3D; (int *)malloc(sizeof(int) * n); for (i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; QuickSort(a, n); return 0;&#125; 各个排序算法的比较","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PTA列出连通集","slug":"PTA列出连通集","date":"2020-08-14T14:08:46.748Z","updated":"2020-08-14T14:13:15.848Z","comments":true,"path":"2020/08/14/PTA列出连通集/","link":"","permalink":"http://yoursite.com/2020/08/14/PTA%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/","excerpt":"涉及BFS和DFS的一道基础遍历题，方便加深对BFS和DFS的理解","text":"涉及BFS和DFS的一道基础遍历题，方便加深对BFS和DFS的理解 题目给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。 输入格式输入第1行给出2个整数N( 0 &lt; N ≤ 10 )和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。 输出格式按照”{ v1, v2, …, vk }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。 输入样例12345678 60 70 12 04 12 43 5 输出样例123456&#123; 0 1 4 2 7 &#125;&#123; 3 5 &#125;&#123; 6 &#125;&#123; 0 1 2 7 4 &#125;&#123; 3 5 &#125;&#123; 6 &#125; C语言解法因为只会加入0到10个顶点，而且顶点从0到N-1编号，所以直接使用邻接矩阵，最大顶点数设10即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXN 10 &#x2F;* 最大顶点数 *&#x2F;int visited[MAXN];int G[MAXN][MAXN], Nv, Ne;void BuildGraph() &#123; int i, j, v1, v2; scanf(&quot;%d&quot;, &amp;Nv); for(i &#x3D; 0; i &lt; Nv; i++) for(j &#x3D; 0; j &lt; Nv; j++) G[i][j] &#x3D; 0; scanf(&quot;%d&quot;, &amp;Ne); for(i &#x3D; 0; i &lt; Ne; i++) &#123; scanf(&quot;%d %d&quot;, &amp;v1, &amp;v2); G[v1][v2] &#x3D; 1; G[v2][v1] &#x3D; 1; &#125;&#125;void DFS(int v) &#123; int i; visited[v] &#x3D; 1; printf(&quot;%d &quot;, v); for(i &#x3D; 0; i &lt; Nv; i++) &#123; if(!visited[i] &amp;&amp; G[v][i] &#x3D;&#x3D; 1) &#123; DFS(i); &#125; &#125;&#125;void BFS(int s) &#123; int queue[11]; int f &#x3D; 0, r &#x3D; 0; int v, i; queue[r++] &#x3D; s; visited[s] &#x3D; 1; printf(&quot;%d &quot;, s); while(f !&#x3D; r) &#123; v &#x3D; queue[f++]; for(i &#x3D; 0; i &lt; Nv; i++) &#123; if(!visited[i] &amp;&amp; G[v][i] &#x3D;&#x3D; 1) &#123; printf(&quot;%d &quot;, i); visited[i] &#x3D; 1; queue[r++] &#x3D; i; &#125; &#125; &#125;&#125;void ClearNums() &#123; memset(visited, 0, sizeof(visited));&#125;int main() &#123; int i; BuildGraph(); for(i &#x3D; 0; i &lt; Nv; i++) &#123; if(!visited[i]) &#123; printf(&quot;&#123; &quot;); DFS(i); printf(&quot;&#125;\\n&quot;); &#125; &#125; ClearNums(); for(i &#x3D; 0; i &lt; Nv; i++) &#123; if(!visited[i]) &#123; printf(&quot;&#123; &quot;); BFS(i); printf(&quot;&#125;\\n&quot;); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"PTA平衡二叉树的根","slug":"PTA平衡二叉树的根","date":"2020-08-12T16:40:18.251Z","updated":"2020-08-12T16:43:41.255Z","comments":true,"path":"2020/08/13/PTA平衡二叉树的根/","link":"","permalink":"http://yoursite.com/2020/08/13/PTA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A0%B9/","excerpt":"涉及到左单旋、右单旋、左右双旋、右左双旋的操作，值得记录","text":"涉及到左单旋、右单旋、左右双旋、右左双旋的操作，值得记录 题目将给定的一系列数字插入初始为空的AVL树，请你输出最后生成的AVL树的根结点的值。 输入格式输入的第一行给出一个正整数N（≤20），随后一行给出N个不同的整数，其间以空格分隔。 输出格式在一行中输出顺序插入上述整数到一棵初始为空的AVL树后，该树的根结点的值。 输入样例112588 70 61 96 120 输出样例1170 输入样例212788 70 61 96 120 90 65 输出样例2188 C语言解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct AVLNode *Position;typedef Position AVLTree; &#x2F;* AVL树类型 *&#x2F;struct AVLNode&#123; ElementType Data; &#x2F;* 结点数据 *&#x2F; AVLTree Left; &#x2F;* 指向左子树 *&#x2F; AVLTree Right; &#x2F;* 指向右子树 *&#x2F; int Height; &#x2F;* 树高 *&#x2F;&#125;;int Max ( int a, int b )&#123; return a &gt; b ? a : b;&#125;int GetHeight( AVLTree A ) &#123; if(A &#x3D;&#x3D; NULL) &#123; return 0; &#125; return A-&gt;Height;&#125;AVLTree SingleLeftRotation ( AVLTree A )&#123; &#x2F;* 注意：A必须有一个左子结点B *&#x2F; &#x2F;* 将A与B做左单旋，更新A与B的高度，返回新的根结点B *&#x2F; AVLTree B &#x3D; A-&gt;Left; A-&gt;Left &#x3D; B-&gt;Right; B-&gt;Right &#x3D; A; A-&gt;Height &#x3D; Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1; B-&gt;Height &#x3D; Max( GetHeight(B-&gt;Left), A-&gt;Height ) + 1; return B;&#125;AVLTree SingleRightRotation ( AVLTree A )&#123; &#x2F;* 注意：A必须有一个右子结点B *&#x2F; &#x2F;* 将A与B做右单旋，更新A与B的高度，返回新的根结点B *&#x2F; AVLTree B &#x3D; A-&gt;Right; A-&gt;Right &#x3D; B-&gt;Left; B-&gt;Left &#x3D; A; A-&gt;Height &#x3D; Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1; B-&gt;Height &#x3D; Max( GetHeight(B-&gt;Right), A-&gt;Height ) + 1; return B;&#125; AVLTree DoubleLeftRightRotation ( AVLTree A )&#123; &#x2F;* 注意：A必须有一个左子结点B，且B必须有一个右子结点C *&#x2F; &#x2F;* 将A、B与C做两次单旋，返回新的根结点C *&#x2F; &#x2F;* 将B与C做右单旋，C被返回 *&#x2F; A-&gt;Left &#x3D; SingleRightRotation(A-&gt;Left); &#x2F;* 将A与C做左单旋，C被返回 *&#x2F; return SingleLeftRotation(A);&#125;AVLTree DoubleRightLeftRotation ( AVLTree A )&#123; &#x2F;* 注意：A必须有一个左子结点B，且B必须有一个右子结点C *&#x2F; &#x2F;* 将A、B与C做两次单旋，返回新的根结点C *&#x2F; &#x2F;* 将B与C做右单旋，C被返回 *&#x2F; A-&gt;Right &#x3D; SingleLeftRotation(A-&gt;Right); &#x2F;* 将A与C做左单旋，C被返回 *&#x2F; return SingleRightRotation(A);&#125;AVLTree Insert( AVLTree T, ElementType X )&#123; &#x2F;* 将X插入AVL树T中，并且返回调整后的AVL树 *&#x2F; if ( !T ) &#123; &#x2F;* 若插入空树，则新建包含一个结点的树 *&#x2F; T &#x3D; (AVLTree)malloc(sizeof(struct AVLNode)); T-&gt;Data &#x3D; X; T-&gt;Height &#x3D; 0; T-&gt;Left &#x3D; T-&gt;Right &#x3D; NULL; &#125; &#x2F;* if (插入空树) 结束 *&#x2F; else if ( X &lt; T-&gt;Data ) &#123; &#x2F;* 插入T的左子树 *&#x2F; T-&gt;Left &#x3D; Insert( T-&gt;Left, X); &#x2F;* 如果需要左旋 *&#x2F; if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) &gt; 1 ) if ( X &lt; T-&gt;Left-&gt;Data ) T &#x3D; SingleLeftRotation(T); &#x2F;* 左单旋 *&#x2F; else T &#x3D; DoubleLeftRightRotation(T); &#x2F;* 左-右双旋 *&#x2F; &#125; &#x2F;* else if (插入左子树) 结束 *&#x2F; else if ( X &gt; T-&gt;Data ) &#123; &#x2F;* 插入T的右子树 *&#x2F; T-&gt;Right &#x3D; Insert( T-&gt;Right, X ); &#x2F;* 如果需要右旋 *&#x2F; if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) &lt; -1 ) if ( X &gt; T-&gt;Right-&gt;Data ) T &#x3D; SingleRightRotation(T); &#x2F;* 右单旋 *&#x2F; else T &#x3D; DoubleRightLeftRotation(T); &#x2F;* 右-左双旋 *&#x2F; &#125; &#x2F;* else if (插入右子树) 结束 *&#x2F; &#x2F;* else X &#x3D;&#x3D; T-&gt;Data，无须插入 *&#x2F; &#x2F;* 别忘了更新树高 *&#x2F; T-&gt;Height &#x3D; Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + 1; return T;&#125;int main() &#123; AVLTree A &#x3D; NULL; int height, X; scanf(&quot;%d&quot;, &amp;height); for(int i &#x3D; 0; i &lt; height; i++) &#123; scanf(&quot;%d&quot;, &amp;X); A &#x3D; Insert(A, X); &#125; printf(&quot;%d\\n&quot;, A-&gt;Data); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"PTA是否同一二叉搜索树","slug":"PTA是否同一二叉搜索树","date":"2020-08-12T16:32:03.807Z","updated":"2020-08-12T16:35:16.324Z","comments":true,"path":"2020/08/13/PTA是否同一二叉搜索树/","link":"","permalink":"http://yoursite.com/2020/08/13/PTA%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"树的基本练习，算是吧。。。","text":"树的基本练习，算是吧。。。 题目给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。 输入格式输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。 简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。 输出格式对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。 输入样例123456784 23 1 4 23 4 1 23 2 4 12 12 11 20 输出样例123YesNoNo C语言解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct TreeNode *Tree;struct TreeNode &#123; int v; Tree Left, Right; int flag;&#125;;Tree NewNode(int V)&#123; Tree T &#x3D; (Tree)malloc(sizeof(struct TreeNode)); T-&gt;v &#x3D; V; T-&gt;Left &#x3D; T-&gt;Right &#x3D; NULL; T-&gt;flag &#x3D; 0; return T;&#125;Tree Insert(Tree T, int V) &#123; if(!T) T &#x3D; NewNode(V); else &#123; if(V &gt; T-&gt;v) T-&gt;Right &#x3D; Insert(T-&gt;Right, V); else T-&gt;Left &#x3D; Insert(T-&gt;Left, V); &#125; return T;&#125;Tree MakeTree(int N)&#123; Tree T; int i, V; scanf(&quot;%d&quot;, &amp;V); T &#x3D; NewNode(V); for(i &#x3D; 1; i &lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;V); T &#x3D; Insert(T, V); &#125; return T;&#125;int check(Tree T, int V) &#123; if(T-&gt;flag) &#123; if(V &lt; T-&gt;v) return check(T-&gt;Left, V); else if(V &gt; T-&gt;v) return check(T-&gt;Right, V); else return 0; &#125; else &#123; if(V &#x3D;&#x3D; T-&gt;v) &#123; T-&gt;flag &#x3D; 1; return 1; &#125; else &#123; return 0; &#125; &#125;&#125;int Judge(Tree T, int N) &#123; int i, V, flag &#x3D; 0; &#x2F;*flag &#x3D; 0代表目前还一致，1代表已经不一致*&#x2F; scanf(&quot;%d&quot;, &amp;V); if(V !&#x3D; T-&gt;v) flag &#x3D; 1; else T-&gt;flag &#x3D; 1; for(i &#x3D; 1; i &lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;V); if((!flag) &amp;&amp; (!check(T, V))) flag &#x3D; 1; &#125; if(flag) return 0; else return 1;&#125;void ResetT(Tree T) &#123; if(T-&gt;Left) ResetT(T-&gt;Left); if(T-&gt;Right) ResetT(T-&gt;Right); T-&gt;flag &#x3D; 0;&#125;void FreeTree(Tree T) &#123; if(T-&gt;Left) FreeTree(T-&gt;Left); if(T-&gt;Right) FreeTree(T-&gt;Right); free(T);&#125;int main() &#123; int N, L, i; Tree T; scanf(&quot;%d&quot;, &amp;N); while(N) &#123; scanf(&quot;%d&quot;, &amp;L); T &#x3D; MakeTree(N); for(i &#x3D; 0; i &lt; L; i++) &#123; if(Judge(T, N)) &#123; printf(&quot;Yes\\n&quot;); &#125; else &#123; printf(&quot;No\\n&quot;); &#125; ResetT(T); &#125; FreeTree(T); scanf(&quot;%d&quot;, &amp;N); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"二叉树搜索树的操作集","slug":"二叉搜索树的操作集","date":"2020-08-12T16:24:21.011Z","updated":"2020-08-12T16:29:16.354Z","comments":true,"path":"2020/08/13/二叉搜索树的操作集/","link":"","permalink":"http://yoursite.com/2020/08/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86/","excerpt":"实现二叉搜索树的5种常用操作，C实现","text":"实现二叉搜索树的5种常用操作，C实现 函数接口定义12345BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST ); 其中 BinTree 结构定义如下 1234567typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;; 函数 Insert 将 X 插入二叉搜索树 BST 并返回结果树的根结点指针； 函数 Delete 将 X 从二叉搜索树 BST 中删除，并返回结果树的根结点指针；如果 X 不在树中，则打印一行 Not Found 并返回原树的根结点指针； 函数 Find 在二叉搜索树 BST 中找到 X ，返回该结点的指针；如果找不到则返回空指针； 函数 FindMin 返回二叉搜索树 BST 中最小元结点的指针； 函数 FindMax 返回二叉搜索树 BST 中最大元结点的指针。 裁判测试程序样例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;;void PreorderTraversal( BinTree BT ); &#x2F;* 先序遍历，由裁判实现，细节不表 *&#x2F;void InorderTraversal( BinTree BT ); &#x2F;* 中序遍历，由裁判实现，细节不表 *&#x2F;BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST );int main()&#123; BinTree BST, MinP, MaxP, Tmp; ElementType X; int N, i; BST &#x3D; NULL; scanf(&quot;%d&quot;, &amp;N); for ( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); BST &#x3D; Insert(BST, X); &#125; printf(&quot;Preorder:&quot;); PreorderTraversal(BST); printf(&quot;\\n&quot;); MinP &#x3D; FindMin(BST); MaxP &#x3D; FindMax(BST); scanf(&quot;%d&quot;, &amp;N); for( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); Tmp &#x3D; Find(BST, X); if (Tmp &#x3D;&#x3D; NULL) printf(&quot;%d is not found\\n&quot;, X); else &#123; printf(&quot;%d is found\\n&quot;, Tmp-&gt;Data); if (Tmp&#x3D;&#x3D;MinP) printf(&quot;%d is the smallest key\\n&quot;, Tmp-&gt;Data); if (Tmp&#x3D;&#x3D;MaxP) printf(&quot;%d is the largest key\\n&quot;, Tmp-&gt;Data); &#125; &#125; scanf(&quot;%d&quot;, &amp;N); for( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); BST &#x3D; Delete(BST, X); &#125; printf(&quot;Inorder:&quot;); InorderTraversal(BST); printf(&quot;\\n&quot;); return 0;&#125;&#x2F;* 你的代码将被嵌在这里 *&#x2F; 输入样例123456105 8 6 2 4 1 0 10 9 756 3 10 0 555 7 0 10 3 输出样例12345678910Preorder: 5 2 1 0 4 8 6 7 10 96 is found3 is not found10 is found10 is the largest key0 is found0 is the smallest key5 is foundNot FoundInorder: 1 2 4 6 8 9 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Position Find( BinTree BST, ElementType X ) &#123; while(BST) &#123; if (X &gt; BST-&gt;Data) &#123; BST &#x3D; BST-&gt;Right; &#125; else if (X &lt; BST-&gt;Data) &#123; BST &#x3D; BST-&gt;Left; &#125; else &#123; return BST; &#125; &#125; return NULL;&#125;Position FindMin( BinTree BST ) &#123; if(BST) &#123; while (BST-&gt;Left) &#123; BST &#x3D; BST-&gt;Left; &#125; &#125; return BST;&#125;Position FindMax( BinTree BST ) &#123; if(BST) &#123; while (BST-&gt;Right) &#123; BST &#x3D; BST-&gt;Right; &#125; &#125; return BST;&#125;BinTree Insert( BinTree BST, ElementType X ) &#123; if(!BST) &#123; BST &#x3D; (BinTree)malloc(sizeof(struct TNode)); BST-&gt;Data &#x3D; X; BST-&gt;Left &#x3D; BST-&gt;Right &#x3D; NULL; &#125; else &#123; if (X &lt; BST-&gt;Data) &#123; BST-&gt;Left &#x3D; Insert(BST-&gt;Left, X); &#125; else if(X &gt; BST-&gt;Data) &#123; BST-&gt;Right &#x3D; Insert(BST-&gt;Right, X); &#125; &#125; return BST;&#125;BinTree Delete( BinTree BST, ElementType X ) &#123; Position Tmp; if (!BST) &#123; printf(&quot;Not Found\\n&quot;); return BST; &#125; if (X &lt; BST-&gt;Data) &#123; BST-&gt;Left &#x3D; Delete(BST-&gt;Left, X); &#125; else if (X &gt; BST-&gt;Data) &#123; BST-&gt;Right &#x3D; Delete(BST-&gt;Right, X); &#125; else &#123; if (BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; Tmp &#x3D; FindMin(BST-&gt;Right); BST-&gt;Data &#x3D; Tmp-&gt;Data; BST-&gt;Right &#x3D; Delete(BST-&gt;Right, BST-&gt;Data); &#125; else &#123; Tmp &#x3D; BST; if(!BST-&gt;Left) &#123; BST &#x3D; BST-&gt;Right; &#125; else &#123; BST &#x3D; BST-&gt;Left; &#125; free(Tmp); &#125; &#125; return BST;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"二叉树遍历","slug":"二叉树遍历","date":"2020-08-12T16:16:47.497Z","updated":"2020-08-12T16:19:37.291Z","comments":true,"path":"2020/08/13/二叉树遍历/","link":"","permalink":"http://yoursite.com/2020/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/","excerpt":"采用递归，不依赖队列的堆栈的四种遍历方法，适合拿来做PTA，C语言走起","text":"采用递归，不依赖队列的堆栈的四种遍历方法，适合拿来做PTA，C语言走起 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;* 先序遍历 *&#x2F;void PreOrderTraversal(BinTree BT) &#123; if (BT) &#123; printf(&quot; %c&quot;, BT-&gt;Data); PreOrderTraversal(BT-&gt;Left); PreOrderTraversal(BT-&gt;Right); &#x2F;&#x2F;递归用法 &#125;&#125;&#x2F;* 中序遍历 *&#x2F;void InOrderTravelsal(BinTree BT) &#123; if (BT) &#123; InOrderTraversal(BT-&gt;Left); printf(&quot; %c&quot;, BT-&gt;Data); InOrderTraversal(BT-&gt;Right); &#x2F;&#x2F;递归用法 &#125;&#125;&#x2F;* 后序遍历 *&#x2F;void PostOrderTravelsal(BinTree BT) &#123; if (BT) &#123; PostOrderTraversal(BT-&gt;Left); PostOrderTraversal(BT-&gt;Right); &#x2F;&#x2F;递归用法 printf(&quot; %c&quot;, BT-&gt;Data); &#125;&#125;&#x2F;* 层序遍历 *&#x2F;void LevelorderTraversal( BinTree BT ) &#123; BinTree t[101]; int i, j; i &#x3D; j &#x3D; 0; t[0] &#x3D; BT; while(BT) &#123; if (BT-&gt;Left) &#123; t[++i] &#x3D; BT-&gt;Left; &#125; if (BT-&gt;Right) &#123; t[++i] &#x3D; BT-&gt;Right; &#125; BinTree temp &#x3D; t[j]; printf(&quot; %c&quot;, temp-&gt;Data); if (i &#x3D;&#x3D; j) &#123; break; &#125; j++; BT &#x3D; t[j]; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"PTA树的同构","slug":"PTA树的同构","date":"2020-08-12T16:07:21.361Z","updated":"2020-08-12T16:13:15.599Z","comments":true,"path":"2020/08/13/PTA树的同构/","link":"","permalink":"http://yoursite.com/2020/08/13/PTA%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/","excerpt":"树的操作，C语言实现，比较难理解的一道题- -|||","text":"树的操作，C语言实现，比较难理解的一道题- -||| 题目给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。 现给定两棵树，请你判断它们是否是同构的。 输入格式输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。 输出格式如果两棵树是同构的，输出“Yes”，否则输出“No”。 输入样例11234567891011121314151617188A 1 2B 3 4C 5 -D - -E 6 -G 7 -F - -H - -8G - 4B 7 6F - -A 5 1H - -C 0 -D - -E 2 - 输出样例11Yes 输入样例21234567891011121314151617188B 5 7F - -A 0 3C 6 -H - -D - -G 4 -E 1 -8D 6 -B 5 -E - -H - -C 0 2G - 3F - -A 1 4 输出样例11No C语言解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MaxTree 10#define ElementType char#define Tree int#define Null -1 struct TreeNode&#123; ElementType Element; Tree Left; Tree Right;&#125;T1[MaxTree], T2[MaxTree]; Tree BuildTree(struct TreeNode T[]);int Isomorphic(Tree R1, Tree R2);int main()&#123; Tree R1, R2; R1 &#x3D; BuildTree(T1); R2 &#x3D; BuildTree(T2); if (Isomorphic(R1, R2)) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); return 0;&#125; Tree BuildTree(struct TreeNode T[])&#123; int N; char cl, cr; int check[MaxTree]; &#x2F;&#x2F; 判断每一个节点有没有节点指向 int Root&#x3D;Null; scanf(&quot;%d\\n&quot;, &amp;N); if (N) &#123; for (int i &#x3D; 0; i &lt; N; i++) check[i] &#x3D; 0; for (int i &#x3D; 0; i &lt; N; i++) &#123; scanf(&quot;%c %c %c\\n&quot;, &amp;T[i].Element, &amp;cl, &amp;cr); if (cl !&#x3D; &#39;-&#39;) &#123; T[i].Left &#x3D; cl - &#39;0&#39;; check[T[i].Left] &#x3D; 1; &#125; else &#123; T[i].Left &#x3D; Null; &#125; if (cr !&#x3D; &#39;-&#39;) &#123; T[i].Right &#x3D; cr - &#39;0&#39;; check[T[i].Right] &#x3D; 1; &#125; else &#123; T[i].Right &#x3D; Null; &#125; &#125; for (int i &#x3D; 0; i &lt; N; i++) &#123; if (!check[i]) &#123; Root &#x3D; i; break; &#125; &#125; &#125; return Root;&#125; int Isomorphic(Tree R1, Tree R2)&#123; if (R1 &#x3D;&#x3D; Null &amp;&amp; R2 &#x3D;&#x3D; Null) return 1; if ((R1 &#x3D;&#x3D; Null &amp;&amp; R2 !&#x3D; Null) || (R2 !&#x3D; Null &amp;&amp; R1 &#x3D;&#x3D; Null)) return 0; if (T1[R1].Element !&#x3D; T2[R2].Element) return 0; if ((T1[R1].Left &#x3D;&#x3D; Null) &amp;&amp; (T2[R2].Left &#x3D;&#x3D; Null)) return Isomorphic(T1[R1].Right, T2[R2].Right); &#x2F;&#x2F; 不需要交换左右子树 if (((T1[R1].Left !&#x3D; Null) &amp;&amp; (T2[R2].Left !&#x3D; Null)) &amp;&amp; ((T1[T1[R1].Left].Element) &#x3D;&#x3D; T2[T2[R2].Left].Element)) &#123; return (Isomorphic(T1[R1].Left, T2[R2].Left))&amp;&amp; (Isomorphic(T1[R1].Right, T2[R2].Right)); &#125; &#x2F;&#x2F; 需要交换左右子数 else &#123; return (Isomorphic(T1[R1].Left, T2[R2].Right)) &amp;&amp; (Isomorphic(T1[R1].Right, T2[R2].Left)); &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"一元多项式的乘法与加法运算","slug":"PTA一元多项式的乘法和加法运算","date":"2020-08-12T16:01:38.546Z","updated":"2020-08-12T16:20:24.127Z","comments":true,"path":"2020/08/13/PTA一元多项式的乘法和加法运算/","link":"","permalink":"http://yoursite.com/2020/08/13/PTA%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E5%92%8C%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/","excerpt":"C语言数组暴力解法，这比课堂上那个简单粗暴多了，方便记忆","text":"C语言数组暴力解法，这比课堂上那个简单粗暴多了，方便记忆 题目设计函数分别求两个一元多项式的乘积与和。 输入格式输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出 0 0。 输入样例124 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1 输出样例1215 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0 C语言解法i作为数组1下标，j作为数组2下标，对应多项式幂，数组存的内容就是系数，注意输出格式就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;string.h&gt;&#x2F;&#x2F;t1,t2分别为0次输入数据，t3为乘法结果，t4为加法结果int t1[1005], t2[1005], t3[2005], t4[1005];#define max 1000&#x2F;&#x2F;输出函数，arr为结果数组，range为最大范围。void show(int *arr, int range)&#123; int i; int tag &#x3D; 0; for(i &#x3D; range; i &gt;&#x3D; 0; --i) &#123; if(arr[i] !&#x3D; 0) &#123; &#x2F;&#x2F;输出的第一项前面没有空格，通过tag进行判断。 if(tag) &#123; printf(&quot; &quot;); &#125; tag &#x3D; 1; printf(&quot;%d %d&quot;, arr[i], i); &#125; &#125; &#x2F;&#x2F;若最终tag为0表示没有输出过，整个结果为0，输出0 0 if(!tag) &#123; printf(&quot;0 0&quot;); &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; int n1, n2, i, j, a, b; &#x2F;&#x2F;数组置0 memset(t1, 0, sizeof(t1)); memset(t2, 0, sizeof(t2)); memset(t3, 0, sizeof(t3)); memset(t4, 0, sizeof(t4)); scanf(&quot;%d&quot;, &amp;n1); for(i &#x3D; 0; i &lt; n1; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); t1[b] &#x3D; a; &#125; scanf(&quot;%d&quot;, &amp;n2); for(i &#x3D; 0; i &lt; n2; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); t2[b] &#x3D; a; &#125; &#x2F;&#x2F;计算乘法 for(i &#x3D; 0; i &lt;&#x3D; max; ++i) &#123; for(j &#x3D; 0; j &lt;&#x3D; max; ++j) &#123; t3[i + j] +&#x3D; t1[i] * t2[j]; &#125; &#125; &#x2F;&#x2F;计算加法 for(i &#x3D; 0; i &lt;&#x3D; max; ++i) &#123; t4[i] &#x3D; t1[i] + t2[i]; &#125; &#x2F;&#x2F;输出 show(t3, max * 2); show(t4, max); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PTA两个有序链表序列的合并","slug":"PTA两个有序链表序列的合并","date":"2020-08-12T15:51:42.151Z","updated":"2020-08-12T15:57:09.694Z","comments":true,"path":"2020/08/12/PTA两个有序链表序列的合并/","link":"","permalink":"http://yoursite.com/2020/08/12/PTA%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6/","excerpt":"考察链表基本操作，C语言解法","text":"考察链表基本操作，C语言解法 本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。 函数接口定义1List Merge( List L1, List L2 ); 其中 List 结构定义如下 123456typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; &#x2F;* 存储结点数据 *&#x2F; PtrToNode Next; &#x2F;* 指向下一个结点的指针 *&#x2F;&#125;;typedef PtrToNode List; &#x2F;* 定义单链表类型 *&#x2F; L1 和 L2 是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数 Merge 要将 L1 和 L2 合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。 裁判测试程序样例1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode List;List Read(); &#x2F;* 细节在此不表 *&#x2F;void Print( List L ); &#x2F;* 细节在此不表；空链表将输出NULL *&#x2F;List Merge( List L1, List L2 );int main()&#123; List L1, L2, L; L1 &#x3D; Read(); L2 &#x3D; Read(); L &#x3D; Merge(L1, L2); Print(L); Print(L1); Print(L2); return 0;&#125;&#x2F;* 你的代码将被嵌在这里 *&#x2F; C语言解法pa遍历L1, pb遍历L2, pc作为桥梁构建合链L 12345678910111213141516171819202122List Merge( List L1, List L2 ) &#123; List pa, pb, pc, L; L &#x3D; (List)malloc(sizeof(struct Node)); pa &#x3D; L1-&gt;Next; pb &#x3D; L2-&gt;Next; pc &#x3D; L; while(pa &amp;&amp; pb) &#123; if (pa-&gt;Data &lt;&#x3D; pb-&gt;Data) &#123; pc-&gt;Next &#x3D; pa; pc &#x3D; pa; pa &#x3D; pa-&gt;Next; &#125; else &#123; pc-&gt;Next &#x3D; pb; pc &#x3D; pb; pb &#x3D; pb-&gt;Next; &#125; &#125; pc-&gt;Next &#x3D; pa ? pa : pb; L1-&gt;Next &#x3D; NULL; L2-&gt;Next &#x3D; NULL; return L;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PTA二分查找法","slug":"PTA二分查找法","date":"2020-08-12T15:40:47.921Z","updated":"2020-08-12T16:21:16.063Z","comments":true,"path":"2020/08/12/PTA二分查找法/","link":"","permalink":"http://yoursite.com/2020/08/12/PTA%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/","excerpt":"挺早学但好像挺重要的，姑且记录一下，还是C语言解法","text":"挺早学但好像挺重要的，姑且记录一下，还是C语言解法 本题要求实现二分查找算法。 函数接口定义1Position BinarySearch( List L, ElementType X ); 其中 List 结构定义如下 123456typedef int Position;typedef struct LNode *List;struct LNode &#123; ElementType Data[MAXSIZE]; Position Last; &#x2F;* 保存线性表中最后一个元素的位置 *&#x2F;&#125;; L 是用户传入的一个线性表，其中 ElementType 元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数 BinarySearch 要查找 X 在 Data 中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记 NotFound 裁判测试程序样例1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10#define NotFound 0typedef int ElementType;typedef int Position;typedef struct LNode *List;struct LNode &#123; ElementType Data[MAXSIZE]; Position Last; &#x2F;* 保存线性表中最后一个元素的位置 *&#x2F;&#125;;List ReadInput(); &#x2F;* 裁判实现，细节不表。元素从下标1开始存储 *&#x2F;Position BinarySearch( List L, ElementType X );int main()&#123; List L; ElementType X; Position P; L &#x3D; ReadInput(); scanf(&quot;%d&quot;, &amp;X); P &#x3D; BinarySearch( L, X ); printf(&quot;%d\\n&quot;, P); return 0;&#125;&#x2F;* 你的代码将被嵌在这里 *&#x2F; C语言解法注意一下数据格式就行 1234567891011121314151617Position BinarySearch( List L, ElementType X ) &#123; int low, high, mid; low &#x3D; 0; high &#x3D; L-&gt;Last; while (low &lt;&#x3D; high) &#123; mid &#x3D; (low + high) &#x2F; 2; if(X &#x3D;&#x3D; L-&gt;Data[mid]) &#123; return mid; &#125; else if(X &lt; L-&gt;Data[mid]) &#123; high &#x3D; mid - 1; &#125;else&#123; low &#x3D; mid + 1; &#125; &#125; return NotFound;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"MaximumSubsequenceSum解法","slug":"MaximumSubsequenceSum解法","date":"2020-08-12T15:34:43.286Z","updated":"2020-08-12T15:39:25.365Z","comments":true,"path":"2020/08/12/MaximumSubsequenceSum解法/","link":"","permalink":"http://yoursite.com/2020/08/12/MaximumSubsequenceSum%E8%A7%A3%E6%B3%95/","excerpt":"最大子列和问题的变种，无非就是多加了找出最大子列和的第一个元素和最后一个元素","text":"最大子列和问题的变种，无非就是多加了找出最大子列和的第一个元素和最后一个元素 特点是在MaxSum更新的时候通过LastTag存入目前加上的数组元素的下标，从而找到最大子列和最后一个元素的下标，再倒推过来找到最大子列和的第一个元素的下标，存入FirstTag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int N, sum, FirstTag, LastTag, ThisSum, MaxSum, j, flag; flag &#x3D; 0; printf(&quot;请输入数字个数：&quot;); scanf(&quot;%d&quot;, &amp;N); int* A &#x3D; (int*)malloc(sizeof(int)*N); printf(&quot;请输入%d个数字：&quot;, N); for(int i &#x3D; 0; i &lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;A[i]); &#125; getchar(); ThisSum &#x3D; MaxSum &#x3D; 0; for (j &#x3D; 0;j &lt; N;j++) &#123; ThisSum +&#x3D; A[j]; if (ThisSum &gt; MaxSum) &#123; MaxSum &#x3D; ThisSum; LastTag &#x3D; j; &#125; else if (ThisSum &lt; 0) ThisSum &#x3D; 0; if(A[j] &gt;&#x3D; 0) &#123; flag &#x3D; 1; &#125; &#125; sum &#x3D; 0; for(int l &#x3D; LastTag; l &gt;&#x3D; 0; l--) &#123; sum +&#x3D; A[l]; if(sum &#x3D;&#x3D; MaxSum) &#123; FirstTag &#x3D; l; &#125; &#125; if(MaxSum) &#123; printf(&quot;最大子序列和为%d\\n&quot;, MaxSum); &#125; else if(flag) &#123; printf(&quot;最大子序列和为0\\n&quot;); &#125; printf(&quot;最大子列和第一个元素为%d, 最后一个元素为%d\\n&quot;, A[FirstTag], A[LastTag]); getchar(); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PTA最大子列和问题","slug":"PTA最大子列和问题","date":"2020-08-12T15:14:14.246Z","updated":"2020-08-12T16:01:41.220Z","comments":true,"path":"2020/08/12/PTA最大子列和问题/","link":"","permalink":"http://yoursite.com/2020/08/12/PTA%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/","excerpt":"采用C语言解法，后续可能会补充其他语种的写法","text":"采用C语言解法，后续可能会补充其他语种的写法 题目给定K个整数组成的序列{ N1, N2, …, NK }，“连续子列”被定义为{ Ni, Ni+1, …, Nj }，其中 1 ≤ i ≤ j ≤ K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下： 数据1：与样例等价，测试基本正确性; 数据2：102个随机整数; 数据3：103个随机整数; 数据4：104个随机整数; 数据5：105个随机整数; 输入格式输入第1行给出正整数K ( ≤100000 )；第2行给出K个整数，其间以空格分隔。 输出格式在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 输入样例126-2 11 -4 13 -5 -2 输出样例120 C语言解法遍历整个数组时，ThisSum作为遍历数组的和，MaxSum不断靠ThisSum更新和大小，ThisSum &lt; 0时ThisSum会清零 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#define MAXN 100000 &#x2F;&#x2F;本题最大数据是十万int MaxSubSequenceSum(const int A[], int N)&#123; int ThisSum, MaxSum, j; ThisSum &#x3D; MaxSum &#x3D; 0; for (j &#x3D; 0;j &lt; N;j++) &#123; ThisSum +&#x3D; A[j]; if (ThisSum &gt; MaxSum) MaxSum &#x3D; ThisSum; else if (ThisSum &lt; 0) ThisSum &#x3D; 0; &#125; return MaxSum;&#125;int main(void) &#123; int K, i; scanf(&quot;%d&quot;, &amp;K); int* a &#x3D; (int*)malloc(sizeof(int)*K); for ( i &#x3D; 0; i &lt; K; i++ ) scanf(&quot;%d&quot;, &amp;a[i]); printf(&quot;%d&quot;, MaxSubSequenceSum( a, K )); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"日语格助词全解","slug":"日语格助词全解","date":"2020-08-12T05:49:18.558Z","updated":"2020-08-12T06:06:19.113Z","comments":true,"path":"2020/08/12/日语格助词全解/","link":"","permalink":"http://yoursite.com/2020/08/12/%E6%97%A5%E8%AF%AD%E6%A0%BC%E5%8A%A9%E8%AF%8D%E5%85%A8%E8%A7%A3/","excerpt":"整理一下日语的所有格助词用法，例如常用的が、を、に 仅供参考，怎么理解还得靠自己","text":"整理一下日语的所有格助词用法，例如常用的が、を、に 仅供参考，怎么理解还得靠自己 什么是格助词？表达单词和动词直接的逻辑关系 日文所有格助词：が を に へ と で から より まで が 表示动作或状态的主题（主词） 例：雨が 降ります りんごが 美味しいで 表示能力或者好恶的「对象」 例：お金が 欲しいです テレビが 買いたいです ドイツ語が できます 加在名词后面成为新名词 例：我が国 を 表示动作的对象 例：水を 飲みます 映画を 見ます 表示移动空间 例：階段を 上がります 公園を 散歩します -&gt; 公園で（で表示动作的场所） 表示某段时间 例：楽しい 時間を 過ごしました 表示离开的场所 例：電車を おります 表示一种感动或者特别提出某一点来讲 例：お忙しところを、どうもすみません に 表示存在的场所 例：つくえをの 上に ノートが あります 表示动作的时间或顺序 例：十時に いきます 一週間に 三回 デートを します（某段时间内的动作频率） 表示拥有者 例：私には 子供が 二人 います 表示动作主 例：私には できません 部下に これを やらせます（使役） 先生に 叱られました（被动） 表示归属附着点 例：電車に 乗ります 壁に ポスターを 貼ります 表示变化结果 例：水が 氷に おりました ～に なります＝～で ございます 紅茶に おります（您点的红茶） 东西的接受者/受惠者（间接对象） 例：子供に おやつを あげます 恋人に 記念品を 買います 表示动作的对象（没有触及对方的抽象动作） 例：お客さんに 会います 先生に 聞きます 母に 何を もらいます 对象抽象 例：あなたの 意見に 賛成します 天文学に 詳しいですね 表示目的 例：新宿へ 買い物に 行きます 原因 例：勉強に 疲れました（心理） -&gt; 勉強で 疲れました（生理） 附加 例：黒のスーツに 黒のネクタイの 男が いる 表示动作的重复 例：走りに 走って やっと 間に合いました へ 动作方向 例：自宅へ 向かいます 部屋へ 戻ります 彼女への プレゼントを 買います と 表示并列 例：教室に 山田さんと 林さんが います 表示一起做某动作的对方 例：花子と 結婚しました 表示对称关系 例：以前と 違います 表示对话或思考的内容 例：安井さんも 行くと 言いましたよ 表示变化的结果 例：雪が 雨と ありました 塵も 積もれば 山と なります 表示加强一种状态 例：うわさは 人から 人へと 伝わるものです あの選手は 小柄ながら 三位と 健闘しました ずっと きっと たっと 二度と で 表示动作的场所 例：教室で 勉強します 教室の中で 弁当を 食べました 表示工具、方法、手段 例：自転車で 行きます 鉛筆で 書きます 表示原因 例：風邪で 会社を 休みました 寒さで 震えます 表示材料 例：紙で 飛行機を 作ります 試験の結果で 判断します 表范围、限度 例：15人で 締め切ります 一週間で 習得します 表示状态 例：今年で 二十歳に なります 大声で 叫びます 表动作者 例：みんあで 協力して 大会を 成功させましぃう 表示最低限度或方法 例：あなたの そばに いるだけで、幸せです から（从……去……） 表示动作或时间的起点 例：学校は 明日から 始まります 大学から でました（从大学走出来） -&gt; 大学を 出ました（从大学毕业） 表动作者 例：そのことは 私から 先生に 伝えますね 表示经过点 例：窓から 入りました 表示原因/理由/判断依据 例：別の立場から 考えます 表示原料（看不出原料的原样）-&gt; で（看得出原料） 例：酒は米から作られます 表示被动式里边的动作者 例：あの先生は みんなから 尊敬されています このことは 同級生から 教えられました まで 表示动作或者事情结束的时间跟地点 例：福岡まで 飛行機で いきました 仕事が 終わるまで 待ちましょう 用「～から ～まで」的句型表示明确的范围 例：仕事は 九時から 五時までです 不明确范围用「～から ～に かけて」 例：東京から 名古屋に かけて 大雨の 恐れが あります 表最低限度，「连……都……」 例：雪まで降ってきた あなたが 泣きと、私もで 悲しく なります より 比较/选择的对象 例：アメリカは 日本より 大きいです 花より 団子 表示地点或者时间的起点 例：四時より 会議を 始めます 遠方より 昔の友達が やってきました 表示一种限定（除了……别的方法） 例：待つより 仕方が ありません","categories":[{"name":"日语","slug":"日语","permalink":"http://yoursite.com/categories/%E6%97%A5%E8%AF%AD/"}],"tags":[{"name":"日语","slug":"日语","permalink":"http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"}]},{"title":"日语动词变形方法全解","slug":"日语动词变形","date":"2020-08-12T03:59:21.241Z","updated":"2020-08-12T04:14:27.009Z","comments":true,"path":"2020/08/12/日语动词变形/","link":"","permalink":"http://yoursite.com/2020/08/12/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/","excerpt":"在学习日语的过程中动词变形还是比较难的一道坎，在此做一个整理。","text":"在学习日语的过程中动词变形还是比较难的一道坎，在此做一个整理。 1、动词ます形变化规则五段动词：将结尾假名变成它同行的前一个假名后+ます 例：行く～行きます 買う～買います 一段动词：去る＋ます 例：食べる～食べます 起きる～起きます カ变动词：来（く）る～来（き）ます サ变动词：する～します 例：勉強する～勉強します 特殊五段动词：帰る～帰ります 知る～知ります 入る～入ります 要る～要ります 切る～切ります 走る～走ります 等2、动词ない形 五段动词：将结尾假名变成它同行的あ段上的假名后+ない。 例：行く→行かない 買う→買わない 一段动词：去る+ない 例：食べる→食べない 起きる→起きない カ变动词：来る→来（こ）ない サ变动词：する→しない 例：勉強する→勉強しない 特殊五段动词：帰る→帰らない 知る→知らない 其它的以此类推，将る变成ら+ない 3、动词可能形五段动词：将结尾假名变成它同行的下一个假名后+る。 例：行く→行ける 買う→買える 一段动词：去る+られる。 例：食べる→食べられる 起きる→起きられる カ变动词：来る→来（こ）られる サ变动词：する→できる 例：勉強する→勉強できる 4、动词て形五段动词： く→いて ぐ→いで 例：書く→書いて 脱ぐ→脱いで う、つ、る为结尾的，去掉う、つ、る＋って 例：買う→買って 立つ→立って 終わる→終わって む、ぬ、ぶ为结尾的去掉+む、ぬ、ぶ＋んで 例：飲む→飲んで 死ぬ→死んで 飛ぶ→飛んで 以す为结尾的す→して 例：話す→話して 一段动词：去る+て 例：食べる→食べて 起きる→起きて カ变动词：来る→来（き）て サ变动词：する→して 例：勉強する→勉強して 例外：行く→行って 帰る→帰って 知る→知って 5、假定形五段动词：将结尾假名变成它同行的下一个假名后+ば 例：行く→行けば 買う→買えば 一段动词：去る+れば 例：食べる→食べれば 起きる→起きれば カ变动词： 来る→来（く）れば サ变动词： する→すれば 例：散歩する→散歩すれば 形容词：去い+ければ 例：安い→安ければ おいしい→おいしければ 形容动词：去だ+なら 例：暇だ→暇なら 簡単だ→簡単なら 名词：名词直接+なら 例：日本人→日本人なら 6、动词意向形五段动词：将结尾假名变成它同行的最后一个假名后+う 例：行く→行こう 買う→買おう 一段动词：去る+よう 例：食べる→食べよう 起きる→起きよう カ变动词： 来る→来（こ）よう サ变动词： する→しよう 例：散歩する→散歩しよう 7、动词命令形五段动词：将结尾假名变成它同行的下一个假名即可. 例：行く→行け 買う→買え 一段动词：去る+ろ 例：起きる→起きろ 食べる→食べろ カ变动词： 来る→来（こ）い サ变动词： する→しろ/せよ 例：勉強する→勉強しろ/せよ 动词禁止形是所有词的字典形（原形、基本形）+な 例：行く→行くな 起きる→起きるな 来る→来（く）るな 勉強する→勉強するな 8、动词被动形五段动词：将结尾假名变成它所在行的あ段上假名后+れる 例：踏む→踏まれる 呼ぶ→呼ばれる 一段动词：去る+られる 例：褒める→褒められる 食べる→食べられる カ变动词： 来る→来（こ）られる サ变动词： する→される 例：発明する→発明される 9、动词使役形五段动词：将结尾假名变成它所在行的あ段上假名后+せる。 例：行く→行かせる 飲む→飲ませる 一段动词：去る+させる 例：食べる→食べさせる 起きる→起きさせる カ变动词： 来る→来（こ）させる サ变动词： する→させる 例：勉強する→勉強させる 沪江日语原文","categories":[{"name":"日语","slug":"日语","permalink":"http://yoursite.com/categories/%E6%97%A5%E8%AF%AD/"}],"tags":[{"name":"日语","slug":"日语","permalink":"http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"}]},{"title":"Hello World!","slug":"hello-world","date":"2020-08-09T12:33:32.266Z","updated":"2020-08-11T07:10:15.243Z","comments":true,"path":"2020/08/09/hello-world/","link":"","permalink":"http://yoursite.com/2020/08/09/hello-world/","excerpt":"A New Start","text":"A New Start 和其他大佬不一样，我是第一次搭建个人博客 多亏大佬们的博文，基于Github Page和hexo搭建的博客上手起来不难，不过还有很多细节需要慢慢添加调整，估计建起一个美观与实用兼顾的博客需要耗费不少精力 - -||| 回到博客这边，为什么要写博客，有以下好处： 觉得懂未必懂，写作是一个很好的反思过程 好记性不如烂笔头，容易遗忘的知识点通过浏览写过的博客能快速重新掌握 结交志同道合的朋友，大佬之间经常通过博客作为交流渠道，不过目前这不是重点 博客的内容大部分会记录我学过的一些知识、错题和遇到的种种BUG，如果学到了大体系的知识也会考虑记录进博客做整理 博客配置，主题采用volantis，使用github进行版本控制，后边可能会考虑用上coding 这是一次全新的开始，祝： 一路开心！","categories":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}],"categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"java","slug":"后端/java","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/java/"},{"name":"Web Server","slug":"后端/Web-Server","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/Web-Server/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"},{"name":"日语","slug":"日语","permalink":"http://yoursite.com/categories/%E6%97%A5%E8%AF%AD/"},{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Web Server","slug":"Web-Server","permalink":"http://yoursite.com/tags/Web-Server/"},{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"日语","slug":"日语","permalink":"http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}